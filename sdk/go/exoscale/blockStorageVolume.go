// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package exoscale

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-exoscale/sdk/go/exoscale/internal"
)

// Manage [Exoscale Block Storage](https://community.exoscale.com/product/storage/block-storage/) Volume.
//
// Block Storage offers persistent externally attached volumes for your workloads.
type BlockStorageVolume struct {
	pulumi.CustomResourceState

	// Volume block size.
	Blocksize pulumi.IntOutput `pulumi:"blocksize"`
	// Volume creation date.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Resource labels.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// Volume name.
	Name pulumi.StringOutput `pulumi:"name"`
	// Volume size in GB (default 10). If volume is attached, instance must be stopped to update this value. Volume can only grow, cannot be shrunk.
	Size pulumi.IntPtrOutput `pulumi:"size"`
	// Block storage snapshot to use when creating a volume. Read-only after creation.
	SnapshotTarget BlockStorageVolumeSnapshotTargetPtrOutput `pulumi:"snapshotTarget"`
	// Volume state.
	State    pulumi.StringOutput                 `pulumi:"state"`
	Timeouts BlockStorageVolumeTimeoutsPtrOutput `pulumi:"timeouts"`
	// ❗ The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
	Zone pulumi.StringOutput `pulumi:"zone"`
}

// NewBlockStorageVolume registers a new resource with the given unique name, arguments, and options.
func NewBlockStorageVolume(ctx *pulumi.Context,
	name string, args *BlockStorageVolumeArgs, opts ...pulumi.ResourceOption) (*BlockStorageVolume, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Zone == nil {
		return nil, errors.New("invalid value for required argument 'Zone'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource BlockStorageVolume
	err := ctx.RegisterResource("exoscale:index/blockStorageVolume:BlockStorageVolume", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBlockStorageVolume gets an existing BlockStorageVolume resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBlockStorageVolume(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BlockStorageVolumeState, opts ...pulumi.ResourceOption) (*BlockStorageVolume, error) {
	var resource BlockStorageVolume
	err := ctx.ReadResource("exoscale:index/blockStorageVolume:BlockStorageVolume", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering BlockStorageVolume resources.
type blockStorageVolumeState struct {
	// Volume block size.
	Blocksize *int `pulumi:"blocksize"`
	// Volume creation date.
	CreatedAt *string `pulumi:"createdAt"`
	// Resource labels.
	Labels map[string]string `pulumi:"labels"`
	// Volume name.
	Name *string `pulumi:"name"`
	// Volume size in GB (default 10). If volume is attached, instance must be stopped to update this value. Volume can only grow, cannot be shrunk.
	Size *int `pulumi:"size"`
	// Block storage snapshot to use when creating a volume. Read-only after creation.
	SnapshotTarget *BlockStorageVolumeSnapshotTarget `pulumi:"snapshotTarget"`
	// Volume state.
	State    *string                     `pulumi:"state"`
	Timeouts *BlockStorageVolumeTimeouts `pulumi:"timeouts"`
	// ❗ The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
	Zone *string `pulumi:"zone"`
}

type BlockStorageVolumeState struct {
	// Volume block size.
	Blocksize pulumi.IntPtrInput
	// Volume creation date.
	CreatedAt pulumi.StringPtrInput
	// Resource labels.
	Labels pulumi.StringMapInput
	// Volume name.
	Name pulumi.StringPtrInput
	// Volume size in GB (default 10). If volume is attached, instance must be stopped to update this value. Volume can only grow, cannot be shrunk.
	Size pulumi.IntPtrInput
	// Block storage snapshot to use when creating a volume. Read-only after creation.
	SnapshotTarget BlockStorageVolumeSnapshotTargetPtrInput
	// Volume state.
	State    pulumi.StringPtrInput
	Timeouts BlockStorageVolumeTimeoutsPtrInput
	// ❗ The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
	Zone pulumi.StringPtrInput
}

func (BlockStorageVolumeState) ElementType() reflect.Type {
	return reflect.TypeOf((*blockStorageVolumeState)(nil)).Elem()
}

type blockStorageVolumeArgs struct {
	// Resource labels.
	Labels map[string]string `pulumi:"labels"`
	// Volume name.
	Name *string `pulumi:"name"`
	// Volume size in GB (default 10). If volume is attached, instance must be stopped to update this value. Volume can only grow, cannot be shrunk.
	Size *int `pulumi:"size"`
	// Block storage snapshot to use when creating a volume. Read-only after creation.
	SnapshotTarget *BlockStorageVolumeSnapshotTarget `pulumi:"snapshotTarget"`
	Timeouts       *BlockStorageVolumeTimeouts       `pulumi:"timeouts"`
	// ❗ The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
	Zone string `pulumi:"zone"`
}

// The set of arguments for constructing a BlockStorageVolume resource.
type BlockStorageVolumeArgs struct {
	// Resource labels.
	Labels pulumi.StringMapInput
	// Volume name.
	Name pulumi.StringPtrInput
	// Volume size in GB (default 10). If volume is attached, instance must be stopped to update this value. Volume can only grow, cannot be shrunk.
	Size pulumi.IntPtrInput
	// Block storage snapshot to use when creating a volume. Read-only after creation.
	SnapshotTarget BlockStorageVolumeSnapshotTargetPtrInput
	Timeouts       BlockStorageVolumeTimeoutsPtrInput
	// ❗ The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
	Zone pulumi.StringInput
}

func (BlockStorageVolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*blockStorageVolumeArgs)(nil)).Elem()
}

type BlockStorageVolumeInput interface {
	pulumi.Input

	ToBlockStorageVolumeOutput() BlockStorageVolumeOutput
	ToBlockStorageVolumeOutputWithContext(ctx context.Context) BlockStorageVolumeOutput
}

func (*BlockStorageVolume) ElementType() reflect.Type {
	return reflect.TypeOf((**BlockStorageVolume)(nil)).Elem()
}

func (i *BlockStorageVolume) ToBlockStorageVolumeOutput() BlockStorageVolumeOutput {
	return i.ToBlockStorageVolumeOutputWithContext(context.Background())
}

func (i *BlockStorageVolume) ToBlockStorageVolumeOutputWithContext(ctx context.Context) BlockStorageVolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BlockStorageVolumeOutput)
}

// BlockStorageVolumeArrayInput is an input type that accepts BlockStorageVolumeArray and BlockStorageVolumeArrayOutput values.
// You can construct a concrete instance of `BlockStorageVolumeArrayInput` via:
//
//	BlockStorageVolumeArray{ BlockStorageVolumeArgs{...} }
type BlockStorageVolumeArrayInput interface {
	pulumi.Input

	ToBlockStorageVolumeArrayOutput() BlockStorageVolumeArrayOutput
	ToBlockStorageVolumeArrayOutputWithContext(context.Context) BlockStorageVolumeArrayOutput
}

type BlockStorageVolumeArray []BlockStorageVolumeInput

func (BlockStorageVolumeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BlockStorageVolume)(nil)).Elem()
}

func (i BlockStorageVolumeArray) ToBlockStorageVolumeArrayOutput() BlockStorageVolumeArrayOutput {
	return i.ToBlockStorageVolumeArrayOutputWithContext(context.Background())
}

func (i BlockStorageVolumeArray) ToBlockStorageVolumeArrayOutputWithContext(ctx context.Context) BlockStorageVolumeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BlockStorageVolumeArrayOutput)
}

// BlockStorageVolumeMapInput is an input type that accepts BlockStorageVolumeMap and BlockStorageVolumeMapOutput values.
// You can construct a concrete instance of `BlockStorageVolumeMapInput` via:
//
//	BlockStorageVolumeMap{ "key": BlockStorageVolumeArgs{...} }
type BlockStorageVolumeMapInput interface {
	pulumi.Input

	ToBlockStorageVolumeMapOutput() BlockStorageVolumeMapOutput
	ToBlockStorageVolumeMapOutputWithContext(context.Context) BlockStorageVolumeMapOutput
}

type BlockStorageVolumeMap map[string]BlockStorageVolumeInput

func (BlockStorageVolumeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BlockStorageVolume)(nil)).Elem()
}

func (i BlockStorageVolumeMap) ToBlockStorageVolumeMapOutput() BlockStorageVolumeMapOutput {
	return i.ToBlockStorageVolumeMapOutputWithContext(context.Background())
}

func (i BlockStorageVolumeMap) ToBlockStorageVolumeMapOutputWithContext(ctx context.Context) BlockStorageVolumeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BlockStorageVolumeMapOutput)
}

type BlockStorageVolumeOutput struct{ *pulumi.OutputState }

func (BlockStorageVolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BlockStorageVolume)(nil)).Elem()
}

func (o BlockStorageVolumeOutput) ToBlockStorageVolumeOutput() BlockStorageVolumeOutput {
	return o
}

func (o BlockStorageVolumeOutput) ToBlockStorageVolumeOutputWithContext(ctx context.Context) BlockStorageVolumeOutput {
	return o
}

// Volume block size.
func (o BlockStorageVolumeOutput) Blocksize() pulumi.IntOutput {
	return o.ApplyT(func(v *BlockStorageVolume) pulumi.IntOutput { return v.Blocksize }).(pulumi.IntOutput)
}

// Volume creation date.
func (o BlockStorageVolumeOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *BlockStorageVolume) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Resource labels.
func (o BlockStorageVolumeOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *BlockStorageVolume) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// Volume name.
func (o BlockStorageVolumeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *BlockStorageVolume) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Volume size in GB (default 10). If volume is attached, instance must be stopped to update this value. Volume can only grow, cannot be shrunk.
func (o BlockStorageVolumeOutput) Size() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BlockStorageVolume) pulumi.IntPtrOutput { return v.Size }).(pulumi.IntPtrOutput)
}

// Block storage snapshot to use when creating a volume. Read-only after creation.
func (o BlockStorageVolumeOutput) SnapshotTarget() BlockStorageVolumeSnapshotTargetPtrOutput {
	return o.ApplyT(func(v *BlockStorageVolume) BlockStorageVolumeSnapshotTargetPtrOutput { return v.SnapshotTarget }).(BlockStorageVolumeSnapshotTargetPtrOutput)
}

// Volume state.
func (o BlockStorageVolumeOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *BlockStorageVolume) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

func (o BlockStorageVolumeOutput) Timeouts() BlockStorageVolumeTimeoutsPtrOutput {
	return o.ApplyT(func(v *BlockStorageVolume) BlockStorageVolumeTimeoutsPtrOutput { return v.Timeouts }).(BlockStorageVolumeTimeoutsPtrOutput)
}

// ❗ The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
func (o BlockStorageVolumeOutput) Zone() pulumi.StringOutput {
	return o.ApplyT(func(v *BlockStorageVolume) pulumi.StringOutput { return v.Zone }).(pulumi.StringOutput)
}

type BlockStorageVolumeArrayOutput struct{ *pulumi.OutputState }

func (BlockStorageVolumeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BlockStorageVolume)(nil)).Elem()
}

func (o BlockStorageVolumeArrayOutput) ToBlockStorageVolumeArrayOutput() BlockStorageVolumeArrayOutput {
	return o
}

func (o BlockStorageVolumeArrayOutput) ToBlockStorageVolumeArrayOutputWithContext(ctx context.Context) BlockStorageVolumeArrayOutput {
	return o
}

func (o BlockStorageVolumeArrayOutput) Index(i pulumi.IntInput) BlockStorageVolumeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *BlockStorageVolume {
		return vs[0].([]*BlockStorageVolume)[vs[1].(int)]
	}).(BlockStorageVolumeOutput)
}

type BlockStorageVolumeMapOutput struct{ *pulumi.OutputState }

func (BlockStorageVolumeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BlockStorageVolume)(nil)).Elem()
}

func (o BlockStorageVolumeMapOutput) ToBlockStorageVolumeMapOutput() BlockStorageVolumeMapOutput {
	return o
}

func (o BlockStorageVolumeMapOutput) ToBlockStorageVolumeMapOutputWithContext(ctx context.Context) BlockStorageVolumeMapOutput {
	return o
}

func (o BlockStorageVolumeMapOutput) MapIndex(k pulumi.StringInput) BlockStorageVolumeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *BlockStorageVolume {
		return vs[0].(map[string]*BlockStorageVolume)[vs[1].(string)]
	}).(BlockStorageVolumeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BlockStorageVolumeInput)(nil)).Elem(), &BlockStorageVolume{})
	pulumi.RegisterInputType(reflect.TypeOf((*BlockStorageVolumeArrayInput)(nil)).Elem(), BlockStorageVolumeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BlockStorageVolumeMapInput)(nil)).Elem(), BlockStorageVolumeMap{})
	pulumi.RegisterOutputType(BlockStorageVolumeOutput{})
	pulumi.RegisterOutputType(BlockStorageVolumeArrayOutput{})
	pulumi.RegisterOutputType(BlockStorageVolumeMapOutput{})
}
