# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'BlockStorageVolumeSnapshotTarget',
    'BlockStorageVolumeSnapshotTimeouts',
    'BlockStorageVolumeSnapshotVolume',
    'BlockStorageVolumeTimeouts',
    'ComputeInstanceNetworkInterface',
    'DatabaseGrafana',
    'DatabaseKafka',
    'DatabaseMysql',
    'DatabaseOpensearch',
    'DatabaseOpensearchDashboards',
    'DatabaseOpensearchIndexPattern',
    'DatabaseOpensearchIndexTemplate',
    'DatabasePg',
    'DatabaseRedis',
    'DatabaseTimeouts',
    'DatabaseValkey',
    'DbaasGrafana',
    'DbaasKafka',
    'DbaasKafkaUserTimeouts',
    'DbaasMysql',
    'DbaasMysqlDatabaseTimeouts',
    'DbaasMysqlUserTimeouts',
    'DbaasOpensearch',
    'DbaasOpensearchDashboards',
    'DbaasOpensearchIndexPattern',
    'DbaasOpensearchIndexTemplate',
    'DbaasOpensearchUserTimeouts',
    'DbaasPg',
    'DbaasPgDatabaseTimeouts',
    'DbaasPgUserTimeouts',
    'DbaasRedis',
    'DbaasTimeouts',
    'DbaasValkey',
    'ElasticIpHealthcheck',
    'IamApiKeyTimeouts',
    'IamOrgPolicyServices',
    'IamOrgPolicyServicesRule',
    'IamOrgPolicyTimeouts',
    'IamRolePolicy',
    'IamRolePolicyServices',
    'IamRolePolicyServicesRule',
    'IamRoleTimeouts',
    'InstancePoolInstance',
    'NlbServiceHealthcheck',
    'SksClusterOidc',
    'SksNodepoolKubeletImageGc',
    'SosBucketPolicyTimeouts',
    'GetBlockStorageVolumeInstanceResult',
    'GetBlockStorageVolumeSnapshotResult',
    'GetBlockStorageVolumeSnapshotTimeoutsResult',
    'GetBlockStorageVolumeSnapshotVolumeResult',
    'GetBlockStorageVolumeTimeoutsResult',
    'GetComputeInstanceListInstanceResult',
    'GetDatabaseUriTimeoutsResult',
    'GetDomainRecordFilterResult',
    'GetDomainRecordRecordResult',
    'GetElasticIpHealthcheckResult',
    'GetIamApiKeyTimeoutsResult',
    'GetIamOrgPolicyServicesResult',
    'GetIamOrgPolicyServicesRuleResult',
    'GetIamOrgPolicyTimeoutsResult',
    'GetIamRolePolicyResult',
    'GetIamRolePolicyServicesResult',
    'GetIamRolePolicyServicesRuleResult',
    'GetIamRoleTimeoutsResult',
    'GetInstancePoolInstanceResult',
    'GetInstancePoolListPoolResult',
    'GetInstancePoolListPoolInstanceResult',
    'GetNlbServiceListServiceResult',
    'GetNlbServiceListServiceHealthcheckResult',
    'GetNlbServiceListTimeoutsResult',
    'GetSksClusterListClusterResult',
    'GetSksClusterListClusterOidcResult',
    'GetSksClusterOidcResult',
    'GetSksNodepoolKubeletImageGcResult',
    'GetSksNodepoolListNodepoolResult',
    'GetSksNodepoolListNodepoolKubeletImageGcResult',
    'GetSosBucketPolicyTimeoutsResult',
]

@pulumi.output_type
class BlockStorageVolumeSnapshotTarget(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        """
        :param builtins.str id: Snapshot ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Snapshot ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BlockStorageVolumeSnapshotTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class BlockStorageVolumeSnapshotVolume(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        """
        :param builtins.str id: Snapshot ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Snapshot ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BlockStorageVolumeTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class ComputeInstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "macAddress":
            suggest = "mac_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: builtins.str,
                 ip_address: Optional[builtins.str] = None,
                 mac_address: Optional[builtins.str] = None):
        """
        :param builtins.str network_id: The exoscale*private*network (ID) to attach to the instance.
        :param builtins.str ip_address: The IPv4 address to request as static DHCP lease if the network interface is attached to a *managed* private network.
        :param builtins.str mac_address: MAC address
        """
        pulumi.set(__self__, "network_id", network_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> builtins.str:
        """
        The exoscale*private*network (ID) to attach to the instance.
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[builtins.str]:
        """
        The IPv4 address to request as static DHCP lease if the network interface is attached to a *managed* private network.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[builtins.str]:
        """
        MAC address
        """
        return pulumi.get(self, "mac_address")


@pulumi.output_type
class DatabaseGrafana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grafanaSettings":
            suggest = "grafana_settings"
        elif key == "ipFilters":
            suggest = "ip_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseGrafana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseGrafana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseGrafana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grafana_settings: Optional[builtins.str] = None,
                 ip_filters: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str grafana_settings: Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        """
        if grafana_settings is not None:
            pulumi.set(__self__, "grafana_settings", grafana_settings)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)

    @property
    @pulumi.getter(name="grafanaSettings")
    def grafana_settings(self) -> Optional[builtins.str]:
        """
        Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        """
        return pulumi.get(self, "grafana_settings")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")


@pulumi.output_type
class DatabaseKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableCertAuth":
            suggest = "enable_cert_auth"
        elif key == "enableKafkaConnect":
            suggest = "enable_kafka_connect"
        elif key == "enableKafkaRest":
            suggest = "enable_kafka_rest"
        elif key == "enableSaslAuth":
            suggest = "enable_sasl_auth"
        elif key == "enableSchemaRegistry":
            suggest = "enable_schema_registry"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaConnectSettings":
            suggest = "kafka_connect_settings"
        elif key == "kafkaRestSettings":
            suggest = "kafka_rest_settings"
        elif key == "kafkaSettings":
            suggest = "kafka_settings"
        elif key == "schemaRegistrySettings":
            suggest = "schema_registry_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_cert_auth: Optional[builtins.bool] = None,
                 enable_kafka_connect: Optional[builtins.bool] = None,
                 enable_kafka_rest: Optional[builtins.bool] = None,
                 enable_sasl_auth: Optional[builtins.bool] = None,
                 enable_schema_registry: Optional[builtins.bool] = None,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 kafka_connect_settings: Optional[builtins.str] = None,
                 kafka_rest_settings: Optional[builtins.str] = None,
                 kafka_settings: Optional[builtins.str] = None,
                 schema_registry_settings: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.bool enable_cert_auth: Enable certificate-based authentication method.
        :param builtins.bool enable_kafka_connect: Enable Kafka Connect.
        :param builtins.bool enable_kafka_rest: Enable Kafka REST.
        :param builtins.bool enable_sasl_auth: Enable SASL-based authentication method.
        :param builtins.bool enable_schema_registry: Enable Schema Registry.
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param builtins.str kafka_connect_settings: Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        :param builtins.str kafka_rest_settings: Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        :param builtins.str kafka_settings: Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        :param builtins.str schema_registry_settings: Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        :param builtins.str version: Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        if enable_cert_auth is not None:
            pulumi.set(__self__, "enable_cert_auth", enable_cert_auth)
        if enable_kafka_connect is not None:
            pulumi.set(__self__, "enable_kafka_connect", enable_kafka_connect)
        if enable_kafka_rest is not None:
            pulumi.set(__self__, "enable_kafka_rest", enable_kafka_rest)
        if enable_sasl_auth is not None:
            pulumi.set(__self__, "enable_sasl_auth", enable_sasl_auth)
        if enable_schema_registry is not None:
            pulumi.set(__self__, "enable_schema_registry", enable_schema_registry)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect_settings is not None:
            pulumi.set(__self__, "kafka_connect_settings", kafka_connect_settings)
        if kafka_rest_settings is not None:
            pulumi.set(__self__, "kafka_rest_settings", kafka_rest_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if schema_registry_settings is not None:
            pulumi.set(__self__, "schema_registry_settings", schema_registry_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableCertAuth")
    def enable_cert_auth(self) -> Optional[builtins.bool]:
        """
        Enable certificate-based authentication method.
        """
        return pulumi.get(self, "enable_cert_auth")

    @property
    @pulumi.getter(name="enableKafkaConnect")
    def enable_kafka_connect(self) -> Optional[builtins.bool]:
        """
        Enable Kafka Connect.
        """
        return pulumi.get(self, "enable_kafka_connect")

    @property
    @pulumi.getter(name="enableKafkaRest")
    def enable_kafka_rest(self) -> Optional[builtins.bool]:
        """
        Enable Kafka REST.
        """
        return pulumi.get(self, "enable_kafka_rest")

    @property
    @pulumi.getter(name="enableSaslAuth")
    def enable_sasl_auth(self) -> Optional[builtins.bool]:
        """
        Enable SASL-based authentication method.
        """
        return pulumi.get(self, "enable_sasl_auth")

    @property
    @pulumi.getter(name="enableSchemaRegistry")
    def enable_schema_registry(self) -> Optional[builtins.bool]:
        """
        Enable Schema Registry.
        """
        return pulumi.get(self, "enable_schema_registry")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaConnectSettings")
    def kafka_connect_settings(self) -> Optional[builtins.str]:
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        return pulumi.get(self, "kafka_connect_settings")

    @property
    @pulumi.getter(name="kafkaRestSettings")
    def kafka_rest_settings(self) -> Optional[builtins.str]:
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        return pulumi.get(self, "kafka_rest_settings")

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[builtins.str]:
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        return pulumi.get(self, "kafka_settings")

    @property
    @pulumi.getter(name="schemaRegistrySettings")
    def schema_registry_settings(self) -> Optional[builtins.str]:
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        return pulumi.get(self, "schema_registry_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "mysqlSettings":
            suggest = "mysql_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[builtins.str] = None,
                 admin_username: Optional[builtins.str] = None,
                 backup_schedule: Optional[builtins.str] = None,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 mysql_settings: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str admin_password: A custom administrator account password (may only be set at creation time).
        :param builtins.str admin_username: A custom administrator account username (may only be set at creation time).
        :param builtins.str backup_schedule: The automated backup schedule (`HH:MM`).
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param builtins.str mysql_settings: MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        :param builtins.str version: MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if mysql_settings is not None:
            pulumi.set(__self__, "mysql_settings", mysql_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[builtins.str]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[builtins.str]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[builtins.str]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional[builtins.str]:
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        return pulumi.get(self, "mysql_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseOpensearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forkFromService":
            suggest = "fork_from_service"
        elif key == "indexPatterns":
            suggest = "index_patterns"
        elif key == "indexTemplate":
            suggest = "index_template"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "keepIndexRefreshInterval":
            suggest = "keep_index_refresh_interval"
        elif key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "recoveryBackupName":
            suggest = "recovery_backup_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboards: Optional['outputs.DatabaseOpensearchDashboards'] = None,
                 fork_from_service: Optional[builtins.str] = None,
                 index_patterns: Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']] = None,
                 index_template: Optional['outputs.DatabaseOpensearchIndexTemplate'] = None,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 keep_index_refresh_interval: Optional[builtins.bool] = None,
                 max_index_count: Optional[builtins.int] = None,
                 recovery_backup_name: Optional[builtins.str] = None,
                 settings: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param 'DatabaseOpensearchDashboardsArgs' dashboards: OpenSearch Dashboards settings
        :param builtins.str fork_from_service: ❗ Service name
        :param Sequence['DatabaseOpensearchIndexPatternArgs'] index_patterns: (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        :param 'DatabaseOpensearchIndexTemplateArgs' index_template: Template settings for all new indexes
        :param Sequence[builtins.str] ip_filters: Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        :param builtins.bool keep_index_refresh_interval: Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param builtins.int max_index_count: Maximum number of indexes to keep (Minimum value is `0`)
        :param builtins.str recovery_backup_name: ❗ Name of a backup to recover from
        :param builtins.str settings: OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        :param builtins.str version: ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        if dashboards is not None:
            pulumi.set(__self__, "dashboards", dashboards)
        if fork_from_service is not None:
            pulumi.set(__self__, "fork_from_service", fork_from_service)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if recovery_backup_name is not None:
            pulumi.set(__self__, "recovery_backup_name", recovery_backup_name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def dashboards(self) -> Optional['outputs.DatabaseOpensearchDashboards']:
        """
        OpenSearch Dashboards settings
        """
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter(name="forkFromService")
    def fork_from_service(self) -> Optional[builtins.str]:
        """
        ❗ Service name
        """
        return pulumi.get(self, "fork_from_service")

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']]:
        """
        (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        """
        return pulumi.get(self, "index_patterns")

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional['outputs.DatabaseOpensearchIndexTemplate']:
        """
        Template settings for all new indexes
        """
        return pulumi.get(self, "index_template")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[builtins.bool]:
        """
        Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @property
    @pulumi.getter(name="maxIndexCount")
    @_utilities.deprecated("""This attribute is deprecated and is ignored""")
    def max_index_count(self) -> Optional[builtins.int]:
        """
        Maximum number of indexes to keep (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter(name="recoveryBackupName")
    def recovery_backup_name(self) -> Optional[builtins.str]:
        """
        ❗ Name of a backup to recover from
        """
        return pulumi.get(self, "recovery_backup_name")

    @property
    @pulumi.getter
    def settings(self) -> Optional[builtins.str]:
        """
        OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseOpensearchDashboards(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxOldSpaceSize":
            suggest = "max_old_space_size"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchDashboards. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchDashboards.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchDashboards.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 max_old_space_size: Optional[builtins.int] = None,
                 request_timeout: Optional[builtins.int] = None):
        """
        :param builtins.bool enabled: Enable or disable OpenSearch Dashboards (default: true).
        :param builtins.int max_old_space_size: Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        :param builtins.int request_timeout: Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Enable or disable OpenSearch Dashboards (default: true).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[builtins.int]:
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        """
        return pulumi.get(self, "max_old_space_size")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[builtins.int]:
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        return pulumi.get(self, "request_timeout")


@pulumi.output_type
class DatabaseOpensearchIndexPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "sortingAlgorithm":
            suggest = "sorting_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchIndexPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchIndexPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchIndexPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_index_count: Optional[builtins.int] = None,
                 pattern: Optional[builtins.str] = None,
                 sorting_algorithm: Optional[builtins.str] = None):
        """
        :param builtins.int max_index_count: Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        :param builtins.str pattern: fnmatch pattern
        :param builtins.str sorting_algorithm: `alphabetical` or `creation_date`.
        """
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if sorting_algorithm is not None:
            pulumi.set(__self__, "sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[builtins.int]:
        """
        Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[builtins.str]:
        """
        fnmatch pattern
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[builtins.str]:
        """
        `alphabetical` or `creation_date`.
        """
        return pulumi.get(self, "sorting_algorithm")


@pulumi.output_type
class DatabaseOpensearchIndexTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingNestedObjectsLimit":
            suggest = "mapping_nested_objects_limit"
        elif key == "numberOfReplicas":
            suggest = "number_of_replicas"
        elif key == "numberOfShards":
            suggest = "number_of_shards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchIndexTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchIndexTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchIndexTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[builtins.int] = None,
                 number_of_replicas: Optional[builtins.int] = None,
                 number_of_shards: Optional[builtins.int] = None):
        """
        :param builtins.int mapping_nested_objects_limit: The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        :param builtins.int number_of_replicas: The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        :param builtins.int number_of_shards: The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[builtins.int]:
        """
        The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        """
        return pulumi.get(self, "mapping_nested_objects_limit")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[builtins.int]:
        """
        The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        """
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[builtins.int]:
        """
        The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class DatabasePg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "pgSettings":
            suggest = "pg_settings"
        elif key == "pgbouncerSettings":
            suggest = "pgbouncer_settings"
        elif key == "pglookoutSettings":
            suggest = "pglookout_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabasePg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabasePg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabasePg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[builtins.str] = None,
                 admin_username: Optional[builtins.str] = None,
                 backup_schedule: Optional[builtins.str] = None,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 pg_settings: Optional[builtins.str] = None,
                 pgbouncer_settings: Optional[builtins.str] = None,
                 pglookout_settings: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str admin_password: A custom administrator account password (may only be set at creation time).
        :param builtins.str admin_username: A custom administrator account username (may only be set at creation time).
        :param builtins.str backup_schedule: The automated backup schedule (`HH:MM`).
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param builtins.str pg_settings: PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        :param builtins.str pgbouncer_settings: PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        :param builtins.str pglookout_settings: pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        :param builtins.str version: PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if pg_settings is not None:
            pulumi.set(__self__, "pg_settings", pg_settings)
        if pgbouncer_settings is not None:
            pulumi.set(__self__, "pgbouncer_settings", pgbouncer_settings)
        if pglookout_settings is not None:
            pulumi.set(__self__, "pglookout_settings", pglookout_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[builtins.str]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[builtins.str]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[builtins.str]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="pgSettings")
    def pg_settings(self) -> Optional[builtins.str]:
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        return pulumi.get(self, "pg_settings")

    @property
    @pulumi.getter(name="pgbouncerSettings")
    def pgbouncer_settings(self) -> Optional[builtins.str]:
        """
        PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        """
        return pulumi.get(self, "pgbouncer_settings")

    @property
    @pulumi.getter(name="pglookoutSettings")
    def pglookout_settings(self) -> Optional[builtins.str]:
        """
        pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        """
        return pulumi.get(self, "pglookout_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "redisSettings":
            suggest = "redis_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 redis_settings: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param builtins.str redis_settings: Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if redis_settings is not None:
            pulumi.set(__self__, "redis_settings", redis_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="redisSettings")
    def redis_settings(self) -> Optional[builtins.str]:
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        return pulumi.get(self, "redis_settings")


@pulumi.output_type
class DatabaseTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 read: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class DatabaseValkey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "valkeySettings":
            suggest = "valkey_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseValkey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseValkey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseValkey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 valkey_settings: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param builtins.str valkey_settings: Valkey configuration settings in JSON format (`exo dbaas type show valkey --settings=valkey` for reference).
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if valkey_settings is not None:
            pulumi.set(__self__, "valkey_settings", valkey_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="valkeySettings")
    def valkey_settings(self) -> Optional[builtins.str]:
        """
        Valkey configuration settings in JSON format (`exo dbaas type show valkey --settings=valkey` for reference).
        """
        return pulumi.get(self, "valkey_settings")


@pulumi.output_type
class DbaasGrafana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grafanaSettings":
            suggest = "grafana_settings"
        elif key == "ipFilters":
            suggest = "ip_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbaasGrafana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbaasGrafana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbaasGrafana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grafana_settings: Optional[builtins.str] = None,
                 ip_filters: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str grafana_settings: Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        """
        if grafana_settings is not None:
            pulumi.set(__self__, "grafana_settings", grafana_settings)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)

    @property
    @pulumi.getter(name="grafanaSettings")
    def grafana_settings(self) -> Optional[builtins.str]:
        """
        Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        """
        return pulumi.get(self, "grafana_settings")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")


@pulumi.output_type
class DbaasKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableCertAuth":
            suggest = "enable_cert_auth"
        elif key == "enableKafkaConnect":
            suggest = "enable_kafka_connect"
        elif key == "enableKafkaRest":
            suggest = "enable_kafka_rest"
        elif key == "enableSaslAuth":
            suggest = "enable_sasl_auth"
        elif key == "enableSchemaRegistry":
            suggest = "enable_schema_registry"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaConnectSettings":
            suggest = "kafka_connect_settings"
        elif key == "kafkaRestSettings":
            suggest = "kafka_rest_settings"
        elif key == "kafkaSettings":
            suggest = "kafka_settings"
        elif key == "schemaRegistrySettings":
            suggest = "schema_registry_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbaasKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbaasKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbaasKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_cert_auth: Optional[builtins.bool] = None,
                 enable_kafka_connect: Optional[builtins.bool] = None,
                 enable_kafka_rest: Optional[builtins.bool] = None,
                 enable_sasl_auth: Optional[builtins.bool] = None,
                 enable_schema_registry: Optional[builtins.bool] = None,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 kafka_connect_settings: Optional[builtins.str] = None,
                 kafka_rest_settings: Optional[builtins.str] = None,
                 kafka_settings: Optional[builtins.str] = None,
                 schema_registry_settings: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.bool enable_cert_auth: Enable certificate-based authentication method.
        :param builtins.bool enable_kafka_connect: Enable Kafka Connect.
        :param builtins.bool enable_kafka_rest: Enable Kafka REST.
        :param builtins.bool enable_sasl_auth: Enable SASL-based authentication method.
        :param builtins.bool enable_schema_registry: Enable Schema Registry.
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param builtins.str kafka_connect_settings: Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        :param builtins.str kafka_rest_settings: Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        :param builtins.str kafka_settings: Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        :param builtins.str schema_registry_settings: Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        :param builtins.str version: Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        if enable_cert_auth is not None:
            pulumi.set(__self__, "enable_cert_auth", enable_cert_auth)
        if enable_kafka_connect is not None:
            pulumi.set(__self__, "enable_kafka_connect", enable_kafka_connect)
        if enable_kafka_rest is not None:
            pulumi.set(__self__, "enable_kafka_rest", enable_kafka_rest)
        if enable_sasl_auth is not None:
            pulumi.set(__self__, "enable_sasl_auth", enable_sasl_auth)
        if enable_schema_registry is not None:
            pulumi.set(__self__, "enable_schema_registry", enable_schema_registry)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect_settings is not None:
            pulumi.set(__self__, "kafka_connect_settings", kafka_connect_settings)
        if kafka_rest_settings is not None:
            pulumi.set(__self__, "kafka_rest_settings", kafka_rest_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if schema_registry_settings is not None:
            pulumi.set(__self__, "schema_registry_settings", schema_registry_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableCertAuth")
    def enable_cert_auth(self) -> Optional[builtins.bool]:
        """
        Enable certificate-based authentication method.
        """
        return pulumi.get(self, "enable_cert_auth")

    @property
    @pulumi.getter(name="enableKafkaConnect")
    def enable_kafka_connect(self) -> Optional[builtins.bool]:
        """
        Enable Kafka Connect.
        """
        return pulumi.get(self, "enable_kafka_connect")

    @property
    @pulumi.getter(name="enableKafkaRest")
    def enable_kafka_rest(self) -> Optional[builtins.bool]:
        """
        Enable Kafka REST.
        """
        return pulumi.get(self, "enable_kafka_rest")

    @property
    @pulumi.getter(name="enableSaslAuth")
    def enable_sasl_auth(self) -> Optional[builtins.bool]:
        """
        Enable SASL-based authentication method.
        """
        return pulumi.get(self, "enable_sasl_auth")

    @property
    @pulumi.getter(name="enableSchemaRegistry")
    def enable_schema_registry(self) -> Optional[builtins.bool]:
        """
        Enable Schema Registry.
        """
        return pulumi.get(self, "enable_schema_registry")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaConnectSettings")
    def kafka_connect_settings(self) -> Optional[builtins.str]:
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        return pulumi.get(self, "kafka_connect_settings")

    @property
    @pulumi.getter(name="kafkaRestSettings")
    def kafka_rest_settings(self) -> Optional[builtins.str]:
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        return pulumi.get(self, "kafka_rest_settings")

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[builtins.str]:
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        return pulumi.get(self, "kafka_settings")

    @property
    @pulumi.getter(name="schemaRegistrySettings")
    def schema_registry_settings(self) -> Optional[builtins.str]:
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        return pulumi.get(self, "schema_registry_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DbaasKafkaUserTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 read: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class DbaasMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "mysqlSettings":
            suggest = "mysql_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbaasMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbaasMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbaasMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[builtins.str] = None,
                 admin_username: Optional[builtins.str] = None,
                 backup_schedule: Optional[builtins.str] = None,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 mysql_settings: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str admin_password: A custom administrator account password (may only be set at creation time).
        :param builtins.str admin_username: A custom administrator account username (may only be set at creation time).
        :param builtins.str backup_schedule: The automated backup schedule (`HH:MM`).
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param builtins.str mysql_settings: MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        :param builtins.str version: MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if mysql_settings is not None:
            pulumi.set(__self__, "mysql_settings", mysql_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[builtins.str]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[builtins.str]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[builtins.str]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional[builtins.str]:
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        return pulumi.get(self, "mysql_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DbaasMysqlDatabaseTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 read: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class DbaasMysqlUserTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 read: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class DbaasOpensearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forkFromService":
            suggest = "fork_from_service"
        elif key == "indexPatterns":
            suggest = "index_patterns"
        elif key == "indexTemplate":
            suggest = "index_template"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "keepIndexRefreshInterval":
            suggest = "keep_index_refresh_interval"
        elif key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "recoveryBackupName":
            suggest = "recovery_backup_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbaasOpensearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbaasOpensearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbaasOpensearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboards: Optional['outputs.DbaasOpensearchDashboards'] = None,
                 fork_from_service: Optional[builtins.str] = None,
                 index_patterns: Optional[Sequence['outputs.DbaasOpensearchIndexPattern']] = None,
                 index_template: Optional['outputs.DbaasOpensearchIndexTemplate'] = None,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 keep_index_refresh_interval: Optional[builtins.bool] = None,
                 max_index_count: Optional[builtins.int] = None,
                 recovery_backup_name: Optional[builtins.str] = None,
                 settings: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param 'DbaasOpensearchDashboardsArgs' dashboards: OpenSearch Dashboards settings
        :param builtins.str fork_from_service: ❗ Service name
        :param Sequence['DbaasOpensearchIndexPatternArgs'] index_patterns: (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        :param 'DbaasOpensearchIndexTemplateArgs' index_template: Template settings for all new indexes
        :param Sequence[builtins.str] ip_filters: Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        :param builtins.bool keep_index_refresh_interval: Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param builtins.int max_index_count: Maximum number of indexes to keep (Minimum value is `0`)
        :param builtins.str recovery_backup_name: ❗ Name of a backup to recover from
        :param builtins.str settings: OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        :param builtins.str version: ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        if dashboards is not None:
            pulumi.set(__self__, "dashboards", dashboards)
        if fork_from_service is not None:
            pulumi.set(__self__, "fork_from_service", fork_from_service)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if recovery_backup_name is not None:
            pulumi.set(__self__, "recovery_backup_name", recovery_backup_name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def dashboards(self) -> Optional['outputs.DbaasOpensearchDashboards']:
        """
        OpenSearch Dashboards settings
        """
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter(name="forkFromService")
    def fork_from_service(self) -> Optional[builtins.str]:
        """
        ❗ Service name
        """
        return pulumi.get(self, "fork_from_service")

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[Sequence['outputs.DbaasOpensearchIndexPattern']]:
        """
        (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        """
        return pulumi.get(self, "index_patterns")

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional['outputs.DbaasOpensearchIndexTemplate']:
        """
        Template settings for all new indexes
        """
        return pulumi.get(self, "index_template")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[builtins.bool]:
        """
        Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @property
    @pulumi.getter(name="maxIndexCount")
    @_utilities.deprecated("""This attribute is deprecated and is ignored""")
    def max_index_count(self) -> Optional[builtins.int]:
        """
        Maximum number of indexes to keep (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter(name="recoveryBackupName")
    def recovery_backup_name(self) -> Optional[builtins.str]:
        """
        ❗ Name of a backup to recover from
        """
        return pulumi.get(self, "recovery_backup_name")

    @property
    @pulumi.getter
    def settings(self) -> Optional[builtins.str]:
        """
        OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DbaasOpensearchDashboards(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxOldSpaceSize":
            suggest = "max_old_space_size"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbaasOpensearchDashboards. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbaasOpensearchDashboards.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbaasOpensearchDashboards.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 max_old_space_size: Optional[builtins.int] = None,
                 request_timeout: Optional[builtins.int] = None):
        """
        :param builtins.bool enabled: Enable or disable OpenSearch Dashboards (default: true).
        :param builtins.int max_old_space_size: Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        :param builtins.int request_timeout: Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Enable or disable OpenSearch Dashboards (default: true).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[builtins.int]:
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        """
        return pulumi.get(self, "max_old_space_size")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[builtins.int]:
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        return pulumi.get(self, "request_timeout")


@pulumi.output_type
class DbaasOpensearchIndexPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "sortingAlgorithm":
            suggest = "sorting_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbaasOpensearchIndexPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbaasOpensearchIndexPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbaasOpensearchIndexPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_index_count: Optional[builtins.int] = None,
                 pattern: Optional[builtins.str] = None,
                 sorting_algorithm: Optional[builtins.str] = None):
        """
        :param builtins.int max_index_count: Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        :param builtins.str pattern: fnmatch pattern
        :param builtins.str sorting_algorithm: `alphabetical` or `creation_date`.
        """
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if sorting_algorithm is not None:
            pulumi.set(__self__, "sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[builtins.int]:
        """
        Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[builtins.str]:
        """
        fnmatch pattern
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[builtins.str]:
        """
        `alphabetical` or `creation_date`.
        """
        return pulumi.get(self, "sorting_algorithm")


@pulumi.output_type
class DbaasOpensearchIndexTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingNestedObjectsLimit":
            suggest = "mapping_nested_objects_limit"
        elif key == "numberOfReplicas":
            suggest = "number_of_replicas"
        elif key == "numberOfShards":
            suggest = "number_of_shards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbaasOpensearchIndexTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbaasOpensearchIndexTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbaasOpensearchIndexTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[builtins.int] = None,
                 number_of_replicas: Optional[builtins.int] = None,
                 number_of_shards: Optional[builtins.int] = None):
        """
        :param builtins.int mapping_nested_objects_limit: The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        :param builtins.int number_of_replicas: The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        :param builtins.int number_of_shards: The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[builtins.int]:
        """
        The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        """
        return pulumi.get(self, "mapping_nested_objects_limit")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[builtins.int]:
        """
        The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        """
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[builtins.int]:
        """
        The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class DbaasOpensearchUserTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 read: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class DbaasPg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "pgSettings":
            suggest = "pg_settings"
        elif key == "pgbouncerSettings":
            suggest = "pgbouncer_settings"
        elif key == "pglookoutSettings":
            suggest = "pglookout_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbaasPg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbaasPg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbaasPg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[builtins.str] = None,
                 admin_username: Optional[builtins.str] = None,
                 backup_schedule: Optional[builtins.str] = None,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 pg_settings: Optional[builtins.str] = None,
                 pgbouncer_settings: Optional[builtins.str] = None,
                 pglookout_settings: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str admin_password: A custom administrator account password (may only be set at creation time).
        :param builtins.str admin_username: A custom administrator account username (may only be set at creation time).
        :param builtins.str backup_schedule: The automated backup schedule (`HH:MM`).
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param builtins.str pg_settings: PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        :param builtins.str pgbouncer_settings: PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        :param builtins.str pglookout_settings: pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        :param builtins.str version: PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if pg_settings is not None:
            pulumi.set(__self__, "pg_settings", pg_settings)
        if pgbouncer_settings is not None:
            pulumi.set(__self__, "pgbouncer_settings", pgbouncer_settings)
        if pglookout_settings is not None:
            pulumi.set(__self__, "pglookout_settings", pglookout_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[builtins.str]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[builtins.str]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[builtins.str]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="pgSettings")
    def pg_settings(self) -> Optional[builtins.str]:
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        return pulumi.get(self, "pg_settings")

    @property
    @pulumi.getter(name="pgbouncerSettings")
    def pgbouncer_settings(self) -> Optional[builtins.str]:
        """
        PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        """
        return pulumi.get(self, "pgbouncer_settings")

    @property
    @pulumi.getter(name="pglookoutSettings")
    def pglookout_settings(self) -> Optional[builtins.str]:
        """
        pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        """
        return pulumi.get(self, "pglookout_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DbaasPgDatabaseTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 read: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class DbaasPgUserTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 read: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class DbaasRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "redisSettings":
            suggest = "redis_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbaasRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbaasRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbaasRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 redis_settings: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param builtins.str redis_settings: Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if redis_settings is not None:
            pulumi.set(__self__, "redis_settings", redis_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="redisSettings")
    def redis_settings(self) -> Optional[builtins.str]:
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        return pulumi.get(self, "redis_settings")


@pulumi.output_type
class DbaasTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 read: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class DbaasValkey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "valkeySettings":
            suggest = "valkey_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbaasValkey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbaasValkey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbaasValkey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[builtins.str]] = None,
                 valkey_settings: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param builtins.str valkey_settings: Valkey configuration settings in JSON format (`exo dbaas type show valkey --settings=valkey` for reference).
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if valkey_settings is not None:
            pulumi.set(__self__, "valkey_settings", valkey_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="valkeySettings")
    def valkey_settings(self) -> Optional[builtins.str]:
        """
        Valkey configuration settings in JSON format (`exo dbaas type show valkey --settings=valkey` for reference).
        """
        return pulumi.get(self, "valkey_settings")


@pulumi.output_type
class ElasticIpHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "strikesFail":
            suggest = "strikes_fail"
        elif key == "strikesOk":
            suggest = "strikes_ok"
        elif key == "tlsSkipVerify":
            suggest = "tls_skip_verify"
        elif key == "tlsSni":
            suggest = "tls_sni"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticIpHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticIpHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticIpHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: builtins.str,
                 port: builtins.int,
                 interval: Optional[builtins.int] = None,
                 strikes_fail: Optional[builtins.int] = None,
                 strikes_ok: Optional[builtins.int] = None,
                 timeout: Optional[builtins.int] = None,
                 tls_skip_verify: Optional[builtins.bool] = None,
                 tls_sni: Optional[builtins.str] = None,
                 uri: Optional[builtins.str] = None):
        """
        :param builtins.str mode: The healthcheck mode (`tcp`, `http` or `https`; may only be set at creation time).
        :param builtins.int port: The healthcheck target port (must be between `1` and `65535`).
        :param builtins.int interval: The healthcheck interval (seconds; must be between `5` and `300`; default: `10`).
        :param builtins.int strikes_fail: The number of failed healthcheck attempts before considering the target unhealthy (must be between `1` and `20`; default: `2`).
        :param builtins.int strikes_ok: The number of successful healthcheck attempts before considering the target healthy (must be between `1` and `20`; default: `3`).
        :param builtins.int timeout: The time before considering a healthcheck probing failed (seconds; must be between `2` and `60`; default: `3`).
        :param builtins.bool tls_skip_verify: Disable TLS certificate verification for healthcheck in `https` mode (boolean; default: `false`).
        :param builtins.str tls_sni: The healthcheck server name to present with SNI in `https` mode.
        :param builtins.str uri: The healthcheck target URI (required in `http(s)` modes).
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if strikes_fail is not None:
            pulumi.set(__self__, "strikes_fail", strikes_fail)
        if strikes_ok is not None:
            pulumi.set(__self__, "strikes_ok", strikes_ok)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        The healthcheck mode (`tcp`, `http` or `https`; may only be set at creation time).
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        The healthcheck target port (must be between `1` and `65535`).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def interval(self) -> Optional[builtins.int]:
        """
        The healthcheck interval (seconds; must be between `5` and `300`; default: `10`).
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> Optional[builtins.int]:
        """
        The number of failed healthcheck attempts before considering the target unhealthy (must be between `1` and `20`; default: `2`).
        """
        return pulumi.get(self, "strikes_fail")

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> Optional[builtins.int]:
        """
        The number of successful healthcheck attempts before considering the target healthy (must be between `1` and `20`; default: `3`).
        """
        return pulumi.get(self, "strikes_ok")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[builtins.int]:
        """
        The time before considering a healthcheck probing failed (seconds; must be between `2` and `60`; default: `3`).
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[builtins.bool]:
        """
        Disable TLS certificate verification for healthcheck in `https` mode (boolean; default: `false`).
        """
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[builtins.str]:
        """
        The healthcheck server name to present with SNI in `https` mode.
        """
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        The healthcheck target URI (required in `http(s)` modes).
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class IamApiKeyTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class IamOrgPolicyServices(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.IamOrgPolicyServicesRule']] = None,
                 type: Optional[builtins.str] = None):
        """
        :param Sequence['IamOrgPolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param builtins.str type: Service type (`rules`, `allow`, or `deny`).
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.IamOrgPolicyServicesRule']]:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IamOrgPolicyServicesRule(dict):
    def __init__(__self__, *,
                 action: Optional[builtins.str] = None,
                 expression: Optional[builtins.str] = None,
                 resources: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str action: IAM policy rule action (`allow` or `deny`).
        :param builtins.str expression: IAM policy rule expression.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    @_utilities.deprecated("""This field is not suported. Specify resources using CEL expressions.""")
    def resources(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "resources")


@pulumi.output_type
class IamOrgPolicyTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class IamRolePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultServiceStrategy":
            suggest = "default_service_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamRolePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamRolePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamRolePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_service_strategy: Optional[builtins.str] = None,
                 services: Optional[Mapping[str, 'outputs.IamRolePolicyServices']] = None):
        """
        :param builtins.str default_service_strategy: Default service strategy (`allow` or `deny`).
        :param Mapping[str, 'IamRolePolicyServicesArgs'] services: IAM policy services.
        """
        if default_service_strategy is not None:
            pulumi.set(__self__, "default_service_strategy", default_service_strategy)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter(name="defaultServiceStrategy")
    def default_service_strategy(self) -> Optional[builtins.str]:
        """
        Default service strategy (`allow` or `deny`).
        """
        return pulumi.get(self, "default_service_strategy")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.IamRolePolicyServices']]:
        """
        IAM policy services.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class IamRolePolicyServices(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.IamRolePolicyServicesRule']] = None,
                 type: Optional[builtins.str] = None):
        """
        :param Sequence['IamRolePolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param builtins.str type: Service type (`rules`, `allow`, or `deny`).
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.IamRolePolicyServicesRule']]:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IamRolePolicyServicesRule(dict):
    def __init__(__self__, *,
                 action: Optional[builtins.str] = None,
                 expression: Optional[builtins.str] = None,
                 resources: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str action: IAM policy rule action (`allow` or `deny`).
        :param builtins.str expression: IAM policy rule expression.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    @_utilities.deprecated("""This field is not suported. Specify resources using CEL expressions.""")
    def resources(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "resources")


@pulumi.output_type
class IamRoleTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class InstancePoolInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[builtins.str] = None,
                 ipv6_address: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 public_ip_address: Optional[builtins.str] = None):
        """
        :param builtins.str id: The ID of this resource.
        :param builtins.str ipv6_address: The instance (main network interface) IPv6 address.
        :param builtins.str name: The instance name.
        :param builtins.str public_ip_address: The instance (main network interface) IPv4 address.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[builtins.str]:
        """
        The instance (main network interface) IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The instance name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[builtins.str]:
        """
        The instance (main network interface) IPv4 address.
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class NlbServiceHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsSni":
            suggest = "tls_sni"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NlbServiceHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NlbServiceHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NlbServiceHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: builtins.int,
                 interval: Optional[builtins.int] = None,
                 mode: Optional[builtins.str] = None,
                 retries: Optional[builtins.int] = None,
                 timeout: Optional[builtins.int] = None,
                 tls_sni: Optional[builtins.str] = None,
                 uri: Optional[builtins.str] = None):
        """
        :param builtins.int port: The NLB service (TCP/UDP) port.
        :param builtins.int interval: The healthcheck interval in seconds (default: `10`).
        :param builtins.str mode: The healthcheck mode (`tcp`|`http`|`https`; default: `tcp`).
        :param builtins.int retries: The healthcheck retries (default: `1`).
        :param builtins.int timeout: The healthcheck timeout (seconds; default: `5`).
        :param builtins.str tls_sni: The healthcheck TLS SNI server name (only if `mode` is `https`).
        :param builtins.str uri: The healthcheck URI (must be set only if `mode` is `http(s)`).
        """
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        The NLB service (TCP/UDP) port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def interval(self) -> Optional[builtins.int]:
        """
        The healthcheck interval in seconds (default: `10`).
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        The healthcheck mode (`tcp`|`http`|`https`; default: `tcp`).
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def retries(self) -> Optional[builtins.int]:
        """
        The healthcheck retries (default: `1`).
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[builtins.int]:
        """
        The healthcheck timeout (seconds; default: `5`).
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[builtins.str]:
        """
        The healthcheck TLS SNI server name (only if `mode` is `https`).
        """
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        The healthcheck URI (must be set only if `mode` is `http(s)`).
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class SksClusterOidc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "groupsClaim":
            suggest = "groups_claim"
        elif key == "groupsPrefix":
            suggest = "groups_prefix"
        elif key == "requiredClaim":
            suggest = "required_claim"
        elif key == "usernameClaim":
            suggest = "username_claim"
        elif key == "usernamePrefix":
            suggest = "username_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SksClusterOidc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SksClusterOidc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SksClusterOidc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: builtins.str,
                 issuer_url: builtins.str,
                 groups_claim: Optional[builtins.str] = None,
                 groups_prefix: Optional[builtins.str] = None,
                 required_claim: Optional[Mapping[str, builtins.str]] = None,
                 username_claim: Optional[builtins.str] = None,
                 username_prefix: Optional[builtins.str] = None):
        """
        :param builtins.str client_id: The OpenID client ID.
        :param builtins.str issuer_url: The OpenID provider URL.
        :param builtins.str groups_claim: An OpenID JWT claim to use as the user's group.
        :param builtins.str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, builtins.str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param builtins.str username_claim: An OpenID JWT claim to use as the user name.
        :param builtins.str username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> builtins.str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[builtins.str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[builtins.str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[builtins.str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[builtins.str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class SksNodepoolKubeletImageGc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highThreshold":
            suggest = "high_threshold"
        elif key == "lowThreshold":
            suggest = "low_threshold"
        elif key == "minAge":
            suggest = "min_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SksNodepoolKubeletImageGc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SksNodepoolKubeletImageGc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SksNodepoolKubeletImageGc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_threshold: Optional[builtins.int] = None,
                 low_threshold: Optional[builtins.int] = None,
                 min_age: Optional[builtins.str] = None):
        """
        :param builtins.int high_threshold: The percent of disk usage after which image garbage collection is always run
        :param builtins.int low_threshold: The percent of disk usage before which image garbage collection is never run
        :param builtins.str min_age: The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        if high_threshold is not None:
            pulumi.set(__self__, "high_threshold", high_threshold)
        if low_threshold is not None:
            pulumi.set(__self__, "low_threshold", low_threshold)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)

    @property
    @pulumi.getter(name="highThreshold")
    def high_threshold(self) -> Optional[builtins.int]:
        """
        The percent of disk usage after which image garbage collection is always run
        """
        return pulumi.get(self, "high_threshold")

    @property
    @pulumi.getter(name="lowThreshold")
    def low_threshold(self) -> Optional[builtins.int]:
        """
        The percent of disk usage before which image garbage collection is never run
        """
        return pulumi.get(self, "low_threshold")

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[builtins.str]:
        """
        The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        return pulumi.get(self, "min_age")


@pulumi.output_type
class SosBucketPolicyTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 read: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class GetBlockStorageVolumeInstanceResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        """
        :param builtins.str id: Instance ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Instance ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBlockStorageVolumeSnapshotResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        """
        :param builtins.str id: Snapshot ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Snapshot ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBlockStorageVolumeSnapshotTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetBlockStorageVolumeSnapshotVolumeResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        """
        :param builtins.str id: Volume ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Volume ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBlockStorageVolumeTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetComputeInstanceListInstanceResult(dict):
    def __init__(__self__, *,
                 anti_affinity_group_ids: Sequence[builtins.str],
                 created_at: builtins.str,
                 deploy_target_id: builtins.str,
                 disk_size: builtins.int,
                 elastic_ip_ids: Sequence[builtins.str],
                 ipv6: builtins.bool,
                 ipv6_address: builtins.str,
                 labels: Mapping[str, builtins.str],
                 manager_id: builtins.str,
                 manager_type: builtins.str,
                 private_network_ids: Sequence[builtins.str],
                 public_ip_address: builtins.str,
                 reverse_dns: builtins.str,
                 security_group_ids: Sequence[builtins.str],
                 ssh_key: builtins.str,
                 ssh_keys: Sequence[builtins.str],
                 state: builtins.str,
                 template_id: builtins.str,
                 type: builtins.str,
                 user_data: builtins.str,
                 zone: builtins.str,
                 id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] anti_affinity_group_ids: The list of attached AntiAffinityGroup (IDs).
        :param builtins.str created_at: The compute instance creation date.
        :param builtins.str deploy_target_id: A deploy target ID.
        :param builtins.int disk_size: The instance disk size (GiB).
        :param Sequence[builtins.str] elastic_ip_ids: The list of attached ElasticIp (IDs).
        :param builtins.bool ipv6: Whether IPv6 is enabled on the instance.
        :param builtins.str ipv6_address: The instance (main network interface) IPv6 address (if enabled).
        :param Mapping[str, builtins.str] labels: A map of key/value labels.
        :param builtins.str manager_id: The instance manager ID, if any.
        :param builtins.str manager_type: The instance manager type (instance pool, SKS node pool, etc.), if any.
        :param Sequence[builtins.str] private_network_ids: The list of attached PrivateNetwork (IDs).
        :param builtins.str public_ip_address: The instance (main network interface) IPv4 address.
        :param builtins.str reverse_dns: Domain name for reverse DNS record.
        :param Sequence[builtins.str] security_group_ids: The list of attached SecurityGroup (IDs).
        :param builtins.str ssh_key: The SshKey (name) authorized on the instance.
        :param Sequence[builtins.str] ssh_keys: The list of SshKey (name) authorized on the instance.
        :param builtins.str state: The instance state.
        :param builtins.str template_id: The instance get_template ID.
        :param builtins.str type: The instance type.
        :param builtins.str user_data: The instance [cloud-init](http://cloudinit.readthedocs.io/en/latest/) configuration.
        :param builtins.str zone: The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
        :param builtins.str id: The compute instance ID to match (conflicts with `name`).
        :param builtins.str name: The instance name to match (conflicts with `id`).
        """
        pulumi.set(__self__, "anti_affinity_group_ids", anti_affinity_group_ids)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deploy_target_id", deploy_target_id)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "elastic_ip_ids", elastic_ip_ids)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "manager_id", manager_id)
        pulumi.set(__self__, "manager_type", manager_type)
        pulumi.set(__self__, "private_network_ids", private_network_ids)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "reverse_dns", reverse_dns)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_data", user_data)
        pulumi.set(__self__, "zone", zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="antiAffinityGroupIds")
    def anti_affinity_group_ids(self) -> Sequence[builtins.str]:
        """
        The list of attached AntiAffinityGroup (IDs).
        """
        return pulumi.get(self, "anti_affinity_group_ids")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> builtins.str:
        """
        The compute instance creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> builtins.str:
        """
        A deploy target ID.
        """
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> builtins.int:
        """
        The instance disk size (GiB).
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="elasticIpIds")
    def elastic_ip_ids(self) -> Sequence[builtins.str]:
        """
        The list of attached ElasticIp (IDs).
        """
        return pulumi.get(self, "elastic_ip_ids")

    @property
    @pulumi.getter
    def ipv6(self) -> builtins.bool:
        """
        Whether IPv6 is enabled on the instance.
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> builtins.str:
        """
        The instance (main network interface) IPv6 address (if enabled).
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, builtins.str]:
        """
        A map of key/value labels.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> builtins.str:
        """
        The instance manager ID, if any.
        """
        return pulumi.get(self, "manager_id")

    @property
    @pulumi.getter(name="managerType")
    def manager_type(self) -> builtins.str:
        """
        The instance manager type (instance pool, SKS node pool, etc.), if any.
        """
        return pulumi.get(self, "manager_type")

    @property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Sequence[builtins.str]:
        """
        The list of attached PrivateNetwork (IDs).
        """
        return pulumi.get(self, "private_network_ids")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> builtins.str:
        """
        The instance (main network interface) IPv4 address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="reverseDns")
    def reverse_dns(self) -> builtins.str:
        """
        Domain name for reverse DNS record.
        """
        return pulumi.get(self, "reverse_dns")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[builtins.str]:
        """
        The list of attached SecurityGroup (IDs).
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="sshKey")
    @_utilities.deprecated("""Use ssh_keys instead""")
    def ssh_key(self) -> builtins.str:
        """
        The SshKey (name) authorized on the instance.
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[builtins.str]:
        """
        The list of SshKey (name) authorized on the instance.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The instance state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> builtins.str:
        """
        The instance get_template ID.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The instance type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> builtins.str:
        """
        The instance [cloud-init](http://cloudinit.readthedocs.io/en/latest/) configuration.
        """
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        """
        The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The compute instance ID to match (conflicts with `name`).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The instance name to match (conflicts with `id`).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDatabaseUriTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetDomainRecordFilterResult(dict):
    def __init__(__self__, *,
                 content_regex: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 record_type: Optional[builtins.str] = None):
        """
        :param builtins.str content_regex: A regular expression to match the record content.
        :param builtins.str id: The record ID to match.
        :param builtins.str name: The domain record name to match.
        :param builtins.str record_type: The record type to match.
        """
        if content_regex is not None:
            pulumi.set(__self__, "content_regex", content_regex)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)

    @property
    @pulumi.getter(name="contentRegex")
    def content_regex(self) -> Optional[builtins.str]:
        """
        A regular expression to match the record content.
        """
        return pulumi.get(self, "content_regex")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The record ID to match.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The domain record name to match.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[builtins.str]:
        """
        The record type to match.
        """
        return pulumi.get(self, "record_type")


@pulumi.output_type
class GetDomainRecordRecordResult(dict):
    def __init__(__self__, *,
                 content: Optional[builtins.str] = None,
                 domain: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 prio: Optional[builtins.int] = None,
                 record_type: Optional[builtins.str] = None,
                 ttl: Optional[builtins.int] = None):
        """
        :param builtins.str content: Content of the Record
        :param builtins.str domain: Domain of the Record
        :param builtins.str id: ID of the Record
        :param builtins.str name: Name of the Record
        :param builtins.int prio: Priority of the Record
        :param builtins.str record_type: Type of the Record
        :param builtins.int ttl: TTL of the Record
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prio is not None:
            pulumi.set(__self__, "prio", prio)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def content(self) -> Optional[builtins.str]:
        """
        Content of the Record
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def domain(self) -> Optional[builtins.str]:
        """
        Domain of the Record
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        ID of the Record
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the Record
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prio(self) -> Optional[builtins.int]:
        """
        Priority of the Record
        """
        return pulumi.get(self, "prio")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[builtins.str]:
        """
        Type of the Record
        """
        return pulumi.get(self, "record_type")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[builtins.int]:
        """
        TTL of the Record
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetElasticIpHealthcheckResult(dict):
    def __init__(__self__, *,
                 interval: builtins.int,
                 mode: builtins.str,
                 port: builtins.int,
                 strikes_fail: builtins.int,
                 strikes_ok: builtins.int,
                 timeout: builtins.int,
                 tls_skip_verify: builtins.bool,
                 tls_sni: builtins.str,
                 uri: builtins.str):
        """
        :param builtins.int interval: The healthcheck interval in seconds.
        :param builtins.str mode: The healthcheck mode.
        :param builtins.int port: The healthcheck target port.
        :param builtins.int strikes_fail: The number of failed healthcheck attempts before considering the target unhealthy.
        :param builtins.int strikes_ok: The number of successful healthcheck attempts before considering the target healthy.
        :param builtins.int timeout: The time in seconds before considering a healthcheck probing failed.
        :param builtins.bool tls_skip_verify: Disable TLS certificate verification for healthcheck in `https` mode.
        :param builtins.str tls_sni: The healthcheck server name to present with SNI in `https` mode.
        :param builtins.str uri: The healthcheck URI.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "strikes_fail", strikes_fail)
        pulumi.set(__self__, "strikes_ok", strikes_ok)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        pulumi.set(__self__, "tls_sni", tls_sni)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def interval(self) -> builtins.int:
        """
        The healthcheck interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        The healthcheck mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        The healthcheck target port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> builtins.int:
        """
        The number of failed healthcheck attempts before considering the target unhealthy.
        """
        return pulumi.get(self, "strikes_fail")

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> builtins.int:
        """
        The number of successful healthcheck attempts before considering the target healthy.
        """
        return pulumi.get(self, "strikes_ok")

    @property
    @pulumi.getter
    def timeout(self) -> builtins.int:
        """
        The time in seconds before considering a healthcheck probing failed.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> builtins.bool:
        """
        Disable TLS certificate verification for healthcheck in `https` mode.
        """
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> builtins.str:
        """
        The healthcheck server name to present with SNI in `https` mode.
        """
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        The healthcheck URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetIamApiKeyTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetIamOrgPolicyServicesResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetIamOrgPolicyServicesRuleResult'],
                 type: builtins.str):
        """
        :param Sequence['GetIamOrgPolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param builtins.str type: Service type (`rules`, `allow`, or `deny`).
        """
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetIamOrgPolicyServicesRuleResult']:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetIamOrgPolicyServicesRuleResult(dict):
    def __init__(__self__, *,
                 action: builtins.str,
                 expression: builtins.str,
                 resources: Sequence[builtins.str]):
        """
        :param builtins.str action: IAM policy rule action (`allow` or `deny`).
        :param builtins.str expression: IAM policy rule expression.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    @_utilities.deprecated("""This field is no longer suported.""")
    def resources(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetIamOrgPolicyTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetIamRolePolicyResult(dict):
    def __init__(__self__, *,
                 default_service_strategy: builtins.str,
                 services: Mapping[str, 'outputs.GetIamRolePolicyServicesResult']):
        """
        :param builtins.str default_service_strategy: Default service strategy (`allow` or `deny`).
        :param Mapping[str, 'GetIamRolePolicyServicesArgs'] services: IAM policy services.
        """
        pulumi.set(__self__, "default_service_strategy", default_service_strategy)
        pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter(name="defaultServiceStrategy")
    def default_service_strategy(self) -> builtins.str:
        """
        Default service strategy (`allow` or `deny`).
        """
        return pulumi.get(self, "default_service_strategy")

    @property
    @pulumi.getter
    def services(self) -> Mapping[str, 'outputs.GetIamRolePolicyServicesResult']:
        """
        IAM policy services.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class GetIamRolePolicyServicesResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetIamRolePolicyServicesRuleResult'],
                 type: builtins.str):
        """
        :param Sequence['GetIamRolePolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param builtins.str type: Service type (`rules`, `allow`, or `deny`).
        """
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetIamRolePolicyServicesRuleResult']:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetIamRolePolicyServicesRuleResult(dict):
    def __init__(__self__, *,
                 action: builtins.str,
                 expression: builtins.str,
                 resources: Sequence[builtins.str]):
        """
        :param builtins.str action: IAM policy rule action (`allow` or `deny`).
        :param builtins.str expression: IAM policy rule expression.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    @_utilities.deprecated("""This field is no longer suported.""")
    def resources(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetIamRoleTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetInstancePoolInstanceResult(dict):
    def __init__(__self__, *,
                 ipv6_address: builtins.str,
                 public_ip_address: builtins.str,
                 id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str ipv6_address: The instance (main network interface) IPv6 address.
        :param builtins.str public_ip_address: The instance (main network interface) IPv4 address.
        :param builtins.str id: The compute instance ID.
        :param builtins.str name: The instance name.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> builtins.str:
        """
        The instance (main network interface) IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> builtins.str:
        """
        The instance (main network interface) IPv4 address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The compute instance ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The instance name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstancePoolListPoolResult(dict):
    def __init__(__self__, *,
                 affinity_group_ids: Sequence[builtins.str],
                 anti_affinity_group_ids: Sequence[builtins.str],
                 deploy_target_id: builtins.str,
                 description: builtins.str,
                 disk_size: builtins.int,
                 elastic_ip_ids: Sequence[builtins.str],
                 instance_prefix: builtins.str,
                 instance_type: builtins.str,
                 instances: Sequence['outputs.GetInstancePoolListPoolInstanceResult'],
                 ipv6: builtins.bool,
                 key_pair: builtins.str,
                 min_available: builtins.int,
                 network_ids: Sequence[builtins.str],
                 security_group_ids: Sequence[builtins.str],
                 size: builtins.int,
                 state: builtins.str,
                 template_id: builtins.str,
                 user_data: builtins.str,
                 zone: builtins.str,
                 id: Optional[builtins.str] = None,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 name: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] affinity_group_ids: The list of attached AntiAffinityGroup (IDs). Use anti_affinity_group_ids instead.
        :param Sequence[builtins.str] anti_affinity_group_ids: The list of attached AntiAffinityGroup (IDs).
        :param builtins.str deploy_target_id: The deploy target ID.
        :param builtins.str description: The instance pool description.
        :param builtins.int disk_size: The managed instances disk size.
        :param Sequence[builtins.str] elastic_ip_ids: The list of attached ElasticIp (IDs).
        :param builtins.str instance_prefix: The string used to prefix the managed instances name.
        :param builtins.str instance_type: The managed instances type.
        :param Sequence['GetInstancePoolListPoolInstanceArgs'] instances: The list of managed instances. Structure is documented below.
        :param builtins.bool ipv6: Whether IPv6 is enabled on managed instances.
        :param builtins.str key_pair: The SshKey (name) authorized on the managed instances.
        :param builtins.int min_available: Minimum number of running Instances.
        :param Sequence[builtins.str] network_ids: The list of attached PrivateNetwork (IDs).
        :param Sequence[builtins.str] security_group_ids: The list of attached SecurityGroup (IDs).
        :param builtins.int size: The number managed instances.
        :param builtins.str state: The pool state.
        :param builtins.str template_id: The managed instances get_template ID.
        :param builtins.str user_data: [cloud-init](http://cloudinit.readthedocs.io/en/latest/) configuration.
        :param builtins.str zone: The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
        :param builtins.str id: The instance pool ID to match (conflicts with `name`).
        :param Mapping[str, builtins.str] labels: A map of key/value labels.
        :param builtins.str name: The pool name to match (conflicts with `id`).
        """
        pulumi.set(__self__, "affinity_group_ids", affinity_group_ids)
        pulumi.set(__self__, "anti_affinity_group_ids", anti_affinity_group_ids)
        pulumi.set(__self__, "deploy_target_id", deploy_target_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "elastic_ip_ids", elastic_ip_ids)
        pulumi.set(__self__, "instance_prefix", instance_prefix)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "key_pair", key_pair)
        pulumi.set(__self__, "min_available", min_available)
        pulumi.set(__self__, "network_ids", network_ids)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "user_data", user_data)
        pulumi.set(__self__, "zone", zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="affinityGroupIds")
    @_utilities.deprecated("""Use anti_affinity_group_ids instead.""")
    def affinity_group_ids(self) -> Sequence[builtins.str]:
        """
        The list of attached AntiAffinityGroup (IDs). Use anti_affinity_group_ids instead.
        """
        return pulumi.get(self, "affinity_group_ids")

    @property
    @pulumi.getter(name="antiAffinityGroupIds")
    def anti_affinity_group_ids(self) -> Sequence[builtins.str]:
        """
        The list of attached AntiAffinityGroup (IDs).
        """
        return pulumi.get(self, "anti_affinity_group_ids")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> builtins.str:
        """
        The deploy target ID.
        """
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The instance pool description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> builtins.int:
        """
        The managed instances disk size.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="elasticIpIds")
    def elastic_ip_ids(self) -> Sequence[builtins.str]:
        """
        The list of attached ElasticIp (IDs).
        """
        return pulumi.get(self, "elastic_ip_ids")

    @property
    @pulumi.getter(name="instancePrefix")
    def instance_prefix(self) -> builtins.str:
        """
        The string used to prefix the managed instances name.
        """
        return pulumi.get(self, "instance_prefix")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> builtins.str:
        """
        The managed instances type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetInstancePoolListPoolInstanceResult']:
        """
        The list of managed instances. Structure is documented below.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def ipv6(self) -> builtins.bool:
        """
        Whether IPv6 is enabled on managed instances.
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="keyPair")
    def key_pair(self) -> builtins.str:
        """
        The SshKey (name) authorized on the managed instances.
        """
        return pulumi.get(self, "key_pair")

    @property
    @pulumi.getter(name="minAvailable")
    def min_available(self) -> builtins.int:
        """
        Minimum number of running Instances.
        """
        return pulumi.get(self, "min_available")

    @property
    @pulumi.getter(name="networkIds")
    def network_ids(self) -> Sequence[builtins.str]:
        """
        The list of attached PrivateNetwork (IDs).
        """
        return pulumi.get(self, "network_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[builtins.str]:
        """
        The list of attached SecurityGroup (IDs).
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter
    def size(self) -> builtins.int:
        """
        The number managed instances.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The pool state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> builtins.str:
        """
        The managed instances get_template ID.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> builtins.str:
        """
        [cloud-init](http://cloudinit.readthedocs.io/en/latest/) configuration.
        """
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        """
        The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The instance pool ID to match (conflicts with `name`).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of key/value labels.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The pool name to match (conflicts with `id`).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstancePoolListPoolInstanceResult(dict):
    def __init__(__self__, *,
                 ipv6_address: builtins.str,
                 public_ip_address: builtins.str,
                 id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str ipv6_address: The instance (main network interface) IPv6 address.
        :param builtins.str public_ip_address: The instance (main network interface) IPv4 address.
        :param builtins.str id: The compute instance ID.
        :param builtins.str name: The instance name.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> builtins.str:
        """
        The instance (main network interface) IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> builtins.str:
        """
        The instance (main network interface) IPv4 address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The compute instance ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The instance name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNlbServiceListServiceResult(dict):
    def __init__(__self__, *,
                 description: builtins.str,
                 healthcheck: 'outputs.GetNlbServiceListServiceHealthcheckResult',
                 id: builtins.str,
                 instance_pool_id: builtins.str,
                 name: builtins.str,
                 port: builtins.int,
                 protocol: builtins.str,
                 state: builtins.str,
                 strategy: builtins.str,
                 target_port: builtins.int):
        """
        :param builtins.str description: NLB service description.
        :param builtins.str id: NLB service ID.
        :param builtins.str instance_pool_id: The exoscale*instance*pool (ID) to forward traffic to.
        :param builtins.str name: NLB Service name.
        :param builtins.int port: Port exposed on the NLB's public IP.
        :param builtins.str protocol: Network traffic protocol.
        :param builtins.str state: NLB Service State.
        :param builtins.str strategy: The strategy (`round-robin`|`source-hash`).
        :param builtins.int target_port: Port on which the network traffic will be forwarded to on the receiving instance.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "healthcheck", healthcheck)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "strategy", strategy)
        pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        NLB service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def healthcheck(self) -> 'outputs.GetNlbServiceListServiceHealthcheckResult':
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        NLB service ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> builtins.str:
        """
        The exoscale*instance*pool (ID) to forward traffic to.
        """
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        NLB Service name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        Port exposed on the NLB's public IP.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> builtins.str:
        """
        Network traffic protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        NLB Service State.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def strategy(self) -> builtins.str:
        """
        The strategy (`round-robin`|`source-hash`).
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> builtins.int:
        """
        Port on which the network traffic will be forwarded to on the receiving instance.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class GetNlbServiceListServiceHealthcheckResult(dict):
    def __init__(__self__, *,
                 interval: builtins.int,
                 mode: builtins.str,
                 port: builtins.int,
                 retries: builtins.int,
                 timeout: builtins.int,
                 tls_sni: builtins.str,
                 uri: builtins.str):
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "retries", retries)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "tls_sni", tls_sni)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def interval(self) -> builtins.int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def retries(self) -> builtins.int:
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> builtins.int:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> builtins.str:
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetNlbServiceListTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetSksClusterListClusterResult(dict):
    def __init__(__self__, *,
                 addons: Sequence[builtins.str],
                 aggregation_ca: builtins.str,
                 control_plane_ca: builtins.str,
                 created_at: builtins.str,
                 enable_kube_proxy: builtins.bool,
                 endpoint: builtins.str,
                 kubelet_ca: builtins.str,
                 nodepools: Sequence[builtins.str],
                 oidc: 'outputs.GetSksClusterListClusterOidcResult',
                 state: builtins.str,
                 version: builtins.str,
                 zone: builtins.str,
                 auto_upgrade: Optional[builtins.bool] = None,
                 cni: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 exoscale_ccm: Optional[builtins.bool] = None,
                 exoscale_csi: Optional[builtins.bool] = None,
                 feature_gates: Optional[Sequence[builtins.str]] = None,
                 id: Optional[builtins.str] = None,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 metrics_server: Optional[builtins.bool] = None,
                 name: Optional[builtins.str] = None,
                 service_level: Optional[builtins.str] = None):
        """
        :param builtins.str aggregation_ca: The CA certificate (in PEM format) for TLS communications between the control plane and the aggregation layer (e.g. `metrics-server`).
        :param builtins.str control_plane_ca: The CA certificate (in PEM format) for TLS communications between control plane components.
        :param builtins.str created_at: The cluster creation date.
        :param builtins.bool enable_kube_proxy: Indicates whether to deploy the Kubernetes network proxy. (may only be set at creation time)
        :param builtins.str endpoint: The cluster API endpoint.
        :param builtins.str kubelet_ca: The CA certificate (in PEM format) for TLS communications between kubelets and the control plane.
        :param Sequence[builtins.str] nodepools: The list of SksNodepool (IDs) attached to the cluster.
        :param 'GetSksClusterListClusterOidcArgs' oidc: An OpenID Connect configuration to provide to the Kubernetes API server (may only be set at creation time). Structure is documented below.
        :param builtins.str state: The cluster state.
        :param builtins.str version: The version of the control plane (default: latest version available from the API; see `exo compute sks versions` for reference; may only be set at creation time).
        :param builtins.bool auto_upgrade: Enable automatic upgrading of the control plane version.
        :param builtins.str cni: The CNI plugin that is to be used. Available options are "calico" or "cilium". Defaults to "calico". Setting empty string will result in a cluster with no CNI.
        :param builtins.str description: A free-form text describing the cluster.
        :param builtins.bool exoscale_ccm: Deploy the Exoscale [Cloud Controller Manager](https://github.com/exoscale/exoscale-cloud-controller-manager/) in the control plane (boolean; default: `true`; may only be set at creation time).
        :param builtins.bool exoscale_csi: Deploy the Exoscale [Container Storage Interface](https://github.com/exoscale/exoscale-csi-driver/) on worker nodes (boolean; default: `false`; requires the CCM to be enabled).
        :param Sequence[builtins.str] feature_gates: Feature gates options for the cluster.
        :param Mapping[str, builtins.str] labels: A map of key/value labels.
        :param builtins.bool metrics_server: Deploy the [Kubernetes Metrics Server](https://github.com/kubernetes-sigs/metrics-server/) in the control plane (boolean; default: `true`; may only be set at creation time).
        :param builtins.str service_level: The service level of the control plane (`pro` or `starter`; default: `pro`; may only be set at creation time).
        """
        pulumi.set(__self__, "addons", addons)
        pulumi.set(__self__, "aggregation_ca", aggregation_ca)
        pulumi.set(__self__, "control_plane_ca", control_plane_ca)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "enable_kube_proxy", enable_kube_proxy)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "kubelet_ca", kubelet_ca)
        pulumi.set(__self__, "nodepools", nodepools)
        pulumi.set(__self__, "oidc", oidc)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zone", zone)
        if auto_upgrade is not None:
            pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        if cni is not None:
            pulumi.set(__self__, "cni", cni)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exoscale_ccm is not None:
            pulumi.set(__self__, "exoscale_ccm", exoscale_ccm)
        if exoscale_csi is not None:
            pulumi.set(__self__, "exoscale_csi", exoscale_csi)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metrics_server is not None:
            pulumi.set(__self__, "metrics_server", metrics_server)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_level is not None:
            pulumi.set(__self__, "service_level", service_level)

    @property
    @pulumi.getter
    @_utilities.deprecated("""This attribute has been replaced by `exoscale_ccm`/`metrics_server` attributes, it will be removed in a future release.""")
    def addons(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "addons")

    @property
    @pulumi.getter(name="aggregationCa")
    def aggregation_ca(self) -> builtins.str:
        """
        The CA certificate (in PEM format) for TLS communications between the control plane and the aggregation layer (e.g. `metrics-server`).
        """
        return pulumi.get(self, "aggregation_ca")

    @property
    @pulumi.getter(name="controlPlaneCa")
    def control_plane_ca(self) -> builtins.str:
        """
        The CA certificate (in PEM format) for TLS communications between control plane components.
        """
        return pulumi.get(self, "control_plane_ca")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> builtins.str:
        """
        The cluster creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="enableKubeProxy")
    def enable_kube_proxy(self) -> builtins.bool:
        """
        Indicates whether to deploy the Kubernetes network proxy. (may only be set at creation time)
        """
        return pulumi.get(self, "enable_kube_proxy")

    @property
    @pulumi.getter
    def endpoint(self) -> builtins.str:
        """
        The cluster API endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kubeletCa")
    def kubelet_ca(self) -> builtins.str:
        """
        The CA certificate (in PEM format) for TLS communications between kubelets and the control plane.
        """
        return pulumi.get(self, "kubelet_ca")

    @property
    @pulumi.getter
    def nodepools(self) -> Sequence[builtins.str]:
        """
        The list of SksNodepool (IDs) attached to the cluster.
        """
        return pulumi.get(self, "nodepools")

    @property
    @pulumi.getter
    def oidc(self) -> 'outputs.GetSksClusterListClusterOidcResult':
        """
        An OpenID Connect configuration to provide to the Kubernetes API server (may only be set at creation time). Structure is documented below.
        """
        return pulumi.get(self, "oidc")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The cluster state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        The version of the control plane (default: latest version available from the API; see `exo compute sks versions` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> Optional[builtins.bool]:
        """
        Enable automatic upgrading of the control plane version.
        """
        return pulumi.get(self, "auto_upgrade")

    @property
    @pulumi.getter
    def cni(self) -> Optional[builtins.str]:
        """
        The CNI plugin that is to be used. Available options are "calico" or "cilium". Defaults to "calico". Setting empty string will result in a cluster with no CNI.
        """
        return pulumi.get(self, "cni")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        A free-form text describing the cluster.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="exoscaleCcm")
    def exoscale_ccm(self) -> Optional[builtins.bool]:
        """
        Deploy the Exoscale [Cloud Controller Manager](https://github.com/exoscale/exoscale-cloud-controller-manager/) in the control plane (boolean; default: `true`; may only be set at creation time).
        """
        return pulumi.get(self, "exoscale_ccm")

    @property
    @pulumi.getter(name="exoscaleCsi")
    def exoscale_csi(self) -> Optional[builtins.bool]:
        """
        Deploy the Exoscale [Container Storage Interface](https://github.com/exoscale/exoscale-csi-driver/) on worker nodes (boolean; default: `false`; requires the CCM to be enabled).
        """
        return pulumi.get(self, "exoscale_csi")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[Sequence[builtins.str]]:
        """
        Feature gates options for the cluster.
        """
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of key/value labels.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="metricsServer")
    def metrics_server(self) -> Optional[builtins.bool]:
        """
        Deploy the [Kubernetes Metrics Server](https://github.com/kubernetes-sigs/metrics-server/) in the control plane (boolean; default: `true`; may only be set at creation time).
        """
        return pulumi.get(self, "metrics_server")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceLevel")
    def service_level(self) -> Optional[builtins.str]:
        """
        The service level of the control plane (`pro` or `starter`; default: `pro`; may only be set at creation time).
        """
        return pulumi.get(self, "service_level")


@pulumi.output_type
class GetSksClusterListClusterOidcResult(dict):
    def __init__(__self__, *,
                 client_id: builtins.str,
                 issuer_url: builtins.str,
                 groups_claim: Optional[builtins.str] = None,
                 groups_prefix: Optional[builtins.str] = None,
                 required_claim: Optional[Mapping[str, builtins.str]] = None,
                 username_claim: Optional[builtins.str] = None,
                 username_prefix: Optional[builtins.str] = None):
        """
        :param builtins.str client_id: The OpenID client ID.
        :param builtins.str issuer_url: The OpenID provider URL.
        :param builtins.str groups_claim: An OpenID JWT claim to use as the user's group.
        :param builtins.str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, builtins.str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param builtins.str username_claim: An OpenID JWT claim to use as the user name.
        :param builtins.str username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> builtins.str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[builtins.str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[builtins.str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[builtins.str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[builtins.str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class GetSksClusterOidcResult(dict):
    def __init__(__self__, *,
                 client_id: builtins.str,
                 issuer_url: builtins.str,
                 groups_claim: Optional[builtins.str] = None,
                 groups_prefix: Optional[builtins.str] = None,
                 required_claim: Optional[Mapping[str, builtins.str]] = None,
                 username_claim: Optional[builtins.str] = None,
                 username_prefix: Optional[builtins.str] = None):
        """
        :param builtins.str client_id: The OpenID client ID.
        :param builtins.str issuer_url: The OpenID provider URL.
        :param builtins.str groups_claim: An OpenID JWT claim to use as the user's group.
        :param builtins.str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, builtins.str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param builtins.str username_claim: An OpenID JWT claim to use as the user name.
        :param builtins.str username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> builtins.str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[builtins.str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[builtins.str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[builtins.str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[builtins.str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class GetSksNodepoolKubeletImageGcResult(dict):
    def __init__(__self__, *,
                 high_threshold: Optional[builtins.int] = None,
                 low_threshold: Optional[builtins.int] = None,
                 min_age: Optional[builtins.str] = None):
        """
        :param builtins.int high_threshold: The percent of disk usage after which image garbage collection is always run
        :param builtins.int low_threshold: The percent of disk usage before which image garbage collection is never run
        :param builtins.str min_age: The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        if high_threshold is not None:
            pulumi.set(__self__, "high_threshold", high_threshold)
        if low_threshold is not None:
            pulumi.set(__self__, "low_threshold", low_threshold)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)

    @property
    @pulumi.getter(name="highThreshold")
    def high_threshold(self) -> Optional[builtins.int]:
        """
        The percent of disk usage after which image garbage collection is always run
        """
        return pulumi.get(self, "high_threshold")

    @property
    @pulumi.getter(name="lowThreshold")
    def low_threshold(self) -> Optional[builtins.int]:
        """
        The percent of disk usage before which image garbage collection is never run
        """
        return pulumi.get(self, "low_threshold")

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[builtins.str]:
        """
        The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        return pulumi.get(self, "min_age")


@pulumi.output_type
class GetSksNodepoolListNodepoolResult(dict):
    def __init__(__self__, *,
                 cluster_id: builtins.str,
                 created_at: builtins.str,
                 instance_pool_id: builtins.str,
                 state: builtins.str,
                 template_id: builtins.str,
                 version: builtins.str,
                 zone: builtins.str,
                 anti_affinity_group_ids: Optional[Sequence[builtins.str]] = None,
                 deploy_target_id: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 disk_size: Optional[builtins.int] = None,
                 id: Optional[builtins.str] = None,
                 instance_prefix: Optional[builtins.str] = None,
                 instance_type: Optional[builtins.str] = None,
                 ipv6: Optional[builtins.bool] = None,
                 kubelet_image_gcs: Optional[Sequence['outputs.GetSksNodepoolListNodepoolKubeletImageGcResult']] = None,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 name: Optional[builtins.str] = None,
                 private_network_ids: Optional[Sequence[builtins.str]] = None,
                 security_group_ids: Optional[Sequence[builtins.str]] = None,
                 size: Optional[builtins.int] = None,
                 storage_lvm: Optional[builtins.bool] = None,
                 taints: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str created_at: The pool creation date.
        :param builtins.str instance_pool_id: The underlying InstancePool ID.
        :param builtins.str state: The current pool state.
        :param builtins.str template_id: The managed instances template ID.
        :param builtins.str version: The managed instances version.
        :param Sequence[builtins.str] anti_affinity_group_ids: A list of AntiAffinityGroup (IDs) to be attached to the managed instances.
        :param builtins.str deploy_target_id: A deploy target ID.
        :param builtins.str description: A free-form text describing the pool.
        :param builtins.int disk_size: The managed instances disk size (GiB; default: `50`).
        :param builtins.str instance_prefix: The string used to prefix the managed instances name (default `pool`).
        :param builtins.str instance_type: The managed compute instances type (`<family>.<size>`, e.g. `standard.medium`; use the [Exoscale CLI](https://github.com/exoscale/cli/) - `exo compute instance-type list` - for the list of available types).
        :param builtins.bool ipv6: Enable IPV6 for the nodepool nodes
        :param Sequence['GetSksNodepoolListNodepoolKubeletImageGcArgs'] kubelet_image_gcs: Configuration for this nodepool's kubelet image garbage collector
        :param Mapping[str, builtins.str] labels: A map of key/value labels.
        :param Sequence[builtins.str] private_network_ids: A list of PrivateNetwork (IDs) to be attached to the managed instances.
        :param Sequence[builtins.str] security_group_ids: A list of SecurityGroup (IDs) to be attached to the managed instances.
        :param builtins.bool storage_lvm: Create nodes with non-standard partitioning for persistent storage (requires min 100G of disk space) (may only be set at creation time).
        :param Mapping[str, builtins.str] taints: A map of key/value Kubernetes [taints](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/) ('taints = { <key> = "<value>:<effect>" }').
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zone", zone)
        if anti_affinity_group_ids is not None:
            pulumi.set(__self__, "anti_affinity_group_ids", anti_affinity_group_ids)
        if deploy_target_id is not None:
            pulumi.set(__self__, "deploy_target_id", deploy_target_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_prefix is not None:
            pulumi.set(__self__, "instance_prefix", instance_prefix)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if kubelet_image_gcs is not None:
            pulumi.set(__self__, "kubelet_image_gcs", kubelet_image_gcs)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_network_ids is not None:
            pulumi.set(__self__, "private_network_ids", private_network_ids)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if storage_lvm is not None:
            pulumi.set(__self__, "storage_lvm", storage_lvm)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> builtins.str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> builtins.str:
        """
        The pool creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> builtins.str:
        """
        The underlying InstancePool ID.
        """
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The current pool state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> builtins.str:
        """
        The managed instances template ID.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        The managed instances version.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="antiAffinityGroupIds")
    def anti_affinity_group_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of AntiAffinityGroup (IDs) to be attached to the managed instances.
        """
        return pulumi.get(self, "anti_affinity_group_ids")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> Optional[builtins.str]:
        """
        A deploy target ID.
        """
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        A free-form text describing the pool.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[builtins.int]:
        """
        The managed instances disk size (GiB; default: `50`).
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instancePrefix")
    def instance_prefix(self) -> Optional[builtins.str]:
        """
        The string used to prefix the managed instances name (default `pool`).
        """
        return pulumi.get(self, "instance_prefix")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[builtins.str]:
        """
        The managed compute instances type (`<family>.<size>`, e.g. `standard.medium`; use the [Exoscale CLI](https://github.com/exoscale/cli/) - `exo compute instance-type list` - for the list of available types).
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[builtins.bool]:
        """
        Enable IPV6 for the nodepool nodes
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="kubeletImageGcs")
    def kubelet_image_gcs(self) -> Optional[Sequence['outputs.GetSksNodepoolListNodepoolKubeletImageGcResult']]:
        """
        Configuration for this nodepool's kubelet image garbage collector
        """
        return pulumi.get(self, "kubelet_image_gcs")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of key/value labels.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of PrivateNetwork (IDs) to be attached to the managed instances.
        """
        return pulumi.get(self, "private_network_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of SecurityGroup (IDs) to be attached to the managed instances.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter
    def size(self) -> Optional[builtins.int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="storageLvm")
    def storage_lvm(self) -> Optional[builtins.bool]:
        """
        Create nodes with non-standard partitioning for persistent storage (requires min 100G of disk space) (may only be set at creation time).
        """
        return pulumi.get(self, "storage_lvm")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of key/value Kubernetes [taints](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/) ('taints = { <key> = "<value>:<effect>" }').
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class GetSksNodepoolListNodepoolKubeletImageGcResult(dict):
    def __init__(__self__, *,
                 high_threshold: Optional[builtins.int] = None,
                 low_threshold: Optional[builtins.int] = None,
                 min_age: Optional[builtins.str] = None):
        """
        :param builtins.int high_threshold: The percent of disk usage after which image garbage collection is always run
        :param builtins.int low_threshold: The percent of disk usage before which image garbage collection is never run
        :param builtins.str min_age: The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        if high_threshold is not None:
            pulumi.set(__self__, "high_threshold", high_threshold)
        if low_threshold is not None:
            pulumi.set(__self__, "low_threshold", low_threshold)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)

    @property
    @pulumi.getter(name="highThreshold")
    def high_threshold(self) -> Optional[builtins.int]:
        """
        The percent of disk usage after which image garbage collection is always run
        """
        return pulumi.get(self, "high_threshold")

    @property
    @pulumi.getter(name="lowThreshold")
    def low_threshold(self) -> Optional[builtins.int]:
        """
        The percent of disk usage before which image garbage collection is never run
        """
        return pulumi.get(self, "low_threshold")

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[builtins.str]:
        """
        The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        return pulumi.get(self, "min_age")


@pulumi.output_type
class GetSosBucketPolicyTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


