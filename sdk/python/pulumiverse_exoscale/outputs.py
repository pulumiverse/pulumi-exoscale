# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ComputeInstanceNetworkInterface',
    'DatabaseKafka',
    'DatabaseMysql',
    'DatabaseOpensearch',
    'DatabaseOpensearchDashboards',
    'DatabaseOpensearchIndexPattern',
    'DatabaseOpensearchIndexTemplate',
    'DatabasePg',
    'DatabaseRedis',
    'ElasticIPHealthcheck',
    'InstancePoolInstance',
    'NLBServiceHealthcheck',
    'SKSClusterOidc',
    'SecurityGroupRulesEgress',
    'SecurityGroupRulesIngress',
    'GetComputeInstanceListInstanceResult',
    'GetDomainRecordFilterResult',
    'GetDomainRecordRecordResult',
    'GetElasticIPHealthcheckResult',
    'GetInstancePoolInstanceResult',
    'GetInstancePoolListPoolResult',
    'GetInstancePoolListPoolInstanceResult',
    'GetSKSClusterListClusterResult',
    'GetSKSClusterListClusterOidcResult',
    'GetSKSClusterOidcResult',
    'GetSKSNodepoolListNodepoolResult',
]

@pulumi.output_type
class ComputeInstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: str,
                 ip_address: Optional[str] = None):
        pulumi.set(__self__, "network_id", network_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class DatabaseKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableCertAuth":
            suggest = "enable_cert_auth"
        elif key == "enableKafkaConnect":
            suggest = "enable_kafka_connect"
        elif key == "enableKafkaRest":
            suggest = "enable_kafka_rest"
        elif key == "enableSaslAuth":
            suggest = "enable_sasl_auth"
        elif key == "enableSchemaRegistry":
            suggest = "enable_schema_registry"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaConnectSettings":
            suggest = "kafka_connect_settings"
        elif key == "kafkaRestSettings":
            suggest = "kafka_rest_settings"
        elif key == "kafkaSettings":
            suggest = "kafka_settings"
        elif key == "schemaRegistrySettings":
            suggest = "schema_registry_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_cert_auth: Optional[bool] = None,
                 enable_kafka_connect: Optional[bool] = None,
                 enable_kafka_rest: Optional[bool] = None,
                 enable_sasl_auth: Optional[bool] = None,
                 enable_schema_registry: Optional[bool] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_connect_settings: Optional[str] = None,
                 kafka_rest_settings: Optional[str] = None,
                 kafka_settings: Optional[str] = None,
                 schema_registry_settings: Optional[str] = None,
                 version: Optional[str] = None):
        if enable_cert_auth is not None:
            pulumi.set(__self__, "enable_cert_auth", enable_cert_auth)
        if enable_kafka_connect is not None:
            pulumi.set(__self__, "enable_kafka_connect", enable_kafka_connect)
        if enable_kafka_rest is not None:
            pulumi.set(__self__, "enable_kafka_rest", enable_kafka_rest)
        if enable_sasl_auth is not None:
            pulumi.set(__self__, "enable_sasl_auth", enable_sasl_auth)
        if enable_schema_registry is not None:
            pulumi.set(__self__, "enable_schema_registry", enable_schema_registry)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect_settings is not None:
            pulumi.set(__self__, "kafka_connect_settings", kafka_connect_settings)
        if kafka_rest_settings is not None:
            pulumi.set(__self__, "kafka_rest_settings", kafka_rest_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if schema_registry_settings is not None:
            pulumi.set(__self__, "schema_registry_settings", schema_registry_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableCertAuth")
    def enable_cert_auth(self) -> Optional[bool]:
        return pulumi.get(self, "enable_cert_auth")

    @property
    @pulumi.getter(name="enableKafkaConnect")
    def enable_kafka_connect(self) -> Optional[bool]:
        return pulumi.get(self, "enable_kafka_connect")

    @property
    @pulumi.getter(name="enableKafkaRest")
    def enable_kafka_rest(self) -> Optional[bool]:
        return pulumi.get(self, "enable_kafka_rest")

    @property
    @pulumi.getter(name="enableSaslAuth")
    def enable_sasl_auth(self) -> Optional[bool]:
        return pulumi.get(self, "enable_sasl_auth")

    @property
    @pulumi.getter(name="enableSchemaRegistry")
    def enable_schema_registry(self) -> Optional[bool]:
        return pulumi.get(self, "enable_schema_registry")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaConnectSettings")
    def kafka_connect_settings(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect_settings")

    @property
    @pulumi.getter(name="kafkaRestSettings")
    def kafka_rest_settings(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest_settings")

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[str]:
        return pulumi.get(self, "kafka_settings")

    @property
    @pulumi.getter(name="schemaRegistrySettings")
    def schema_registry_settings(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "mysqlSettings":
            suggest = "mysql_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_schedule: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 mysql_settings: Optional[str] = None,
                 version: Optional[str] = None):
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if mysql_settings is not None:
            pulumi.set(__self__, "mysql_settings", mysql_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[str]:
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional[str]:
        return pulumi.get(self, "mysql_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseOpensearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forkFromService":
            suggest = "fork_from_service"
        elif key == "indexPatterns":
            suggest = "index_patterns"
        elif key == "indexTemplate":
            suggest = "index_template"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "keepIndexRefreshInterval":
            suggest = "keep_index_refresh_interval"
        elif key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "recoveryBackupName":
            suggest = "recovery_backup_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboards: Optional['outputs.DatabaseOpensearchDashboards'] = None,
                 fork_from_service: Optional[str] = None,
                 index_patterns: Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']] = None,
                 index_template: Optional['outputs.DatabaseOpensearchIndexTemplate'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 keep_index_refresh_interval: Optional[bool] = None,
                 max_index_count: Optional[int] = None,
                 recovery_backup_name: Optional[str] = None,
                 settings: Optional[str] = None,
                 version: Optional[str] = None):
        if dashboards is not None:
            pulumi.set(__self__, "dashboards", dashboards)
        if fork_from_service is not None:
            pulumi.set(__self__, "fork_from_service", fork_from_service)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if recovery_backup_name is not None:
            pulumi.set(__self__, "recovery_backup_name", recovery_backup_name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def dashboards(self) -> Optional['outputs.DatabaseOpensearchDashboards']:
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter(name="forkFromService")
    def fork_from_service(self) -> Optional[str]:
        return pulumi.get(self, "fork_from_service")

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']]:
        return pulumi.get(self, "index_patterns")

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional['outputs.DatabaseOpensearchIndexTemplate']:
        return pulumi.get(self, "index_template")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[bool]:
        return pulumi.get(self, "keep_index_refresh_interval")

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[int]:
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter(name="recoveryBackupName")
    def recovery_backup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_backup_name")

    @property
    @pulumi.getter
    def settings(self) -> Optional[str]:
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseOpensearchDashboards(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxOldSpaceSize":
            suggest = "max_old_space_size"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchDashboards. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchDashboards.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchDashboards.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 max_old_space_size: Optional[int] = None,
                 request_timeout: Optional[int] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[int]:
        return pulumi.get(self, "max_old_space_size")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[int]:
        return pulumi.get(self, "request_timeout")


@pulumi.output_type
class DatabaseOpensearchIndexPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "sortingAlgorithm":
            suggest = "sorting_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchIndexPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchIndexPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchIndexPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_index_count: Optional[int] = None,
                 pattern: Optional[str] = None,
                 sorting_algorithm: Optional[str] = None):
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if sorting_algorithm is not None:
            pulumi.set(__self__, "sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[int]:
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[str]:
        return pulumi.get(self, "sorting_algorithm")


@pulumi.output_type
class DatabaseOpensearchIndexTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingNestedObjectsLimit":
            suggest = "mapping_nested_objects_limit"
        elif key == "numberOfReplicas":
            suggest = "number_of_replicas"
        elif key == "numberOfShards":
            suggest = "number_of_shards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchIndexTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchIndexTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchIndexTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[int] = None,
                 number_of_replicas: Optional[int] = None,
                 number_of_shards: Optional[int] = None):
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[int]:
        return pulumi.get(self, "mapping_nested_objects_limit")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[int]:
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[int]:
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class DatabasePg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "pgSettings":
            suggest = "pg_settings"
        elif key == "pgbouncerSettings":
            suggest = "pgbouncer_settings"
        elif key == "pglookoutSettings":
            suggest = "pglookout_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabasePg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabasePg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabasePg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_schedule: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 pg_settings: Optional[str] = None,
                 pgbouncer_settings: Optional[str] = None,
                 pglookout_settings: Optional[str] = None,
                 version: Optional[str] = None):
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if pg_settings is not None:
            pulumi.set(__self__, "pg_settings", pg_settings)
        if pgbouncer_settings is not None:
            pulumi.set(__self__, "pgbouncer_settings", pgbouncer_settings)
        if pglookout_settings is not None:
            pulumi.set(__self__, "pglookout_settings", pglookout_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[str]:
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="pgSettings")
    def pg_settings(self) -> Optional[str]:
        return pulumi.get(self, "pg_settings")

    @property
    @pulumi.getter(name="pgbouncerSettings")
    def pgbouncer_settings(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer_settings")

    @property
    @pulumi.getter(name="pglookoutSettings")
    def pglookout_settings(self) -> Optional[str]:
        return pulumi.get(self, "pglookout_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "redisSettings":
            suggest = "redis_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 redis_settings: Optional[str] = None):
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if redis_settings is not None:
            pulumi.set(__self__, "redis_settings", redis_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="redisSettings")
    def redis_settings(self) -> Optional[str]:
        return pulumi.get(self, "redis_settings")


@pulumi.output_type
class ElasticIPHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "strikesFail":
            suggest = "strikes_fail"
        elif key == "strikesOk":
            suggest = "strikes_ok"
        elif key == "tlsSkipVerify":
            suggest = "tls_skip_verify"
        elif key == "tlsSni":
            suggest = "tls_sni"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticIPHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticIPHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticIPHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: str,
                 port: int,
                 interval: Optional[int] = None,
                 strikes_fail: Optional[int] = None,
                 strikes_ok: Optional[int] = None,
                 timeout: Optional[int] = None,
                 tls_skip_verify: Optional[bool] = None,
                 tls_sni: Optional[str] = None,
                 uri: Optional[str] = None):
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if strikes_fail is not None:
            pulumi.set(__self__, "strikes_fail", strikes_fail)
        if strikes_ok is not None:
            pulumi.set(__self__, "strikes_ok", strikes_ok)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> Optional[int]:
        return pulumi.get(self, "strikes_fail")

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> Optional[int]:
        return pulumi.get(self, "strikes_ok")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[bool]:
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[str]:
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        return pulumi.get(self, "uri")


@pulumi.output_type
class InstancePoolInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 ipv6_address: Optional[str] = None,
                 name: Optional[str] = None,
                 public_ip_address: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[str]:
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class NLBServiceHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsSni":
            suggest = "tls_sni"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NLBServiceHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NLBServiceHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NLBServiceHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 interval: Optional[int] = None,
                 mode: Optional[str] = None,
                 retries: Optional[int] = None,
                 timeout: Optional[int] = None,
                 tls_sni: Optional[str] = None,
                 uri: Optional[str] = None):
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[str]:
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        return pulumi.get(self, "uri")


@pulumi.output_type
class SKSClusterOidc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "groupsClaim":
            suggest = "groups_claim"
        elif key == "groupsPrefix":
            suggest = "groups_prefix"
        elif key == "requiredClaim":
            suggest = "required_claim"
        elif key == "usernameClaim":
            suggest = "username_claim"
        elif key == "usernamePrefix":
            suggest = "username_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SKSClusterOidc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SKSClusterOidc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SKSClusterOidc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claim: Optional[str] = None,
                 groups_prefix: Optional[str] = None,
                 required_claim: Optional[Mapping[str, str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[str]:
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class SecurityGroupRulesEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrLists":
            suggest = "cidr_lists"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "userSecurityGroupLists":
            suggest = "user_security_group_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupRulesEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupRulesEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupRulesEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_lists: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 icmp_code: Optional[int] = None,
                 icmp_type: Optional[int] = None,
                 ids: Optional[Sequence[str]] = None,
                 ports: Optional[Sequence[str]] = None,
                 protocol: Optional[str] = None,
                 user_security_group_lists: Optional[Sequence[str]] = None):
        if cidr_lists is not None:
            pulumi.set(__self__, "cidr_lists", cidr_lists)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if user_security_group_lists is not None:
            pulumi.set(__self__, "user_security_group_lists", user_security_group_lists)

    @property
    @pulumi.getter(name="cidrLists")
    def cidr_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cidr_lists")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[int]:
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[int]:
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="userSecurityGroupLists")
    def user_security_group_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "user_security_group_lists")


@pulumi.output_type
class SecurityGroupRulesIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrLists":
            suggest = "cidr_lists"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "userSecurityGroupLists":
            suggest = "user_security_group_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupRulesIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupRulesIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupRulesIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_lists: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 icmp_code: Optional[int] = None,
                 icmp_type: Optional[int] = None,
                 ids: Optional[Sequence[str]] = None,
                 ports: Optional[Sequence[str]] = None,
                 protocol: Optional[str] = None,
                 user_security_group_lists: Optional[Sequence[str]] = None):
        if cidr_lists is not None:
            pulumi.set(__self__, "cidr_lists", cidr_lists)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if user_security_group_lists is not None:
            pulumi.set(__self__, "user_security_group_lists", user_security_group_lists)

    @property
    @pulumi.getter(name="cidrLists")
    def cidr_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cidr_lists")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[int]:
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[int]:
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="userSecurityGroupLists")
    def user_security_group_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "user_security_group_lists")


@pulumi.output_type
class GetComputeInstanceListInstanceResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 deploy_target_id: str,
                 disk_size: int,
                 elastic_ip_ids: Sequence[str],
                 ipv6: bool,
                 ipv6_address: str,
                 manager_id: str,
                 manager_type: str,
                 private_network_ids: Sequence[str],
                 public_ip_address: str,
                 reverse_dns: str,
                 security_group_ids: Sequence[str],
                 ssh_key: str,
                 state: str,
                 template_id: str,
                 type: str,
                 user_data: str,
                 zone: str,
                 anti_affinity_group_ids: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None):
        """
        :param str created_at: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str deploy_target_id: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param int disk_size: Match against this int
        :param bool ipv6: Match against this bool
        :param str ipv6_address: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str manager_id: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str manager_type: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str public_ip_address: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str reverse_dns: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str ssh_key: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str state: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str template_id: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str type: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str user_data: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str zone: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str id: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param Mapping[str, str] labels: Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
        :param str name: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deploy_target_id", deploy_target_id)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "elastic_ip_ids", elastic_ip_ids)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "manager_id", manager_id)
        pulumi.set(__self__, "manager_type", manager_type)
        pulumi.set(__self__, "private_network_ids", private_network_ids)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "reverse_dns", reverse_dns)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_data", user_data)
        pulumi.set(__self__, "zone", zone)
        if anti_affinity_group_ids is not None:
            pulumi.set(__self__, "anti_affinity_group_ids", anti_affinity_group_ids)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Match against this int
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="elasticIpIds")
    def elastic_ip_ids(self) -> Sequence[str]:
        return pulumi.get(self, "elastic_ip_ids")

    @property
    @pulumi.getter
    def ipv6(self) -> bool:
        """
        Match against this bool
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "manager_id")

    @property
    @pulumi.getter(name="managerType")
    def manager_type(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "manager_type")

    @property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Sequence[str]:
        return pulumi.get(self, "private_network_ids")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="reverseDns")
    def reverse_dns(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "reverse_dns")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="antiAffinityGroupIds")
    def anti_affinity_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "anti_affinity_group_ids")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDomainRecordFilterResult(dict):
    def __init__(__self__, *,
                 content_regex: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 record_type: Optional[str] = None):
        """
        :param str content_regex: A regular expression to match the record content.
        :param str id: The record ID to match.
        :param str name: The domain record name to match.
        :param str record_type: The record type to match.
        """
        if content_regex is not None:
            pulumi.set(__self__, "content_regex", content_regex)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)

    @property
    @pulumi.getter(name="contentRegex")
    def content_regex(self) -> Optional[str]:
        """
        A regular expression to match the record content.
        """
        return pulumi.get(self, "content_regex")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The record ID to match.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The domain record name to match.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        """
        The record type to match.
        """
        return pulumi.get(self, "record_type")


@pulumi.output_type
class GetDomainRecordRecordResult(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 domain: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 prio: Optional[int] = None,
                 record_type: Optional[str] = None,
                 ttl: Optional[int] = None):
        """
        :param str domain: The Domain name to match.
        :param str id: The ID of this resource.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prio is not None:
            pulumi.set(__self__, "prio", prio)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The Domain name to match.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prio(self) -> Optional[int]:
        return pulumi.get(self, "prio")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        return pulumi.get(self, "record_type")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetElasticIPHealthcheckResult(dict):
    def __init__(__self__, *,
                 interval: int,
                 mode: str,
                 port: int,
                 strikes_fail: int,
                 strikes_ok: int,
                 timeout: int,
                 tls_skip_verify: bool,
                 tls_sni: str,
                 uri: str):
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "strikes_fail", strikes_fail)
        pulumi.set(__self__, "strikes_ok", strikes_ok)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        pulumi.set(__self__, "tls_sni", tls_sni)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def interval(self) -> int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> int:
        return pulumi.get(self, "strikes_fail")

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> int:
        return pulumi.get(self, "strikes_ok")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> bool:
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> str:
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetInstancePoolInstanceResult(dict):
    def __init__(__self__, *,
                 ipv6_address: str,
                 public_ip_address: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The instance pool ID to match (conflicts with `name`).
        :param str name: The pool name to match (conflicts with `id`).
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The instance pool ID to match (conflicts with `name`).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The pool name to match (conflicts with `id`).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstancePoolListPoolResult(dict):
    def __init__(__self__, *,
                 affinity_group_ids: Sequence[str],
                 deploy_target_id: str,
                 description: str,
                 disk_size: int,
                 elastic_ip_ids: Sequence[str],
                 instance_prefix: str,
                 instance_type: str,
                 instances: Sequence['outputs.GetInstancePoolListPoolInstanceResult'],
                 ipv6: bool,
                 key_pair: str,
                 network_ids: Sequence[str],
                 security_group_ids: Sequence[str],
                 size: int,
                 state: str,
                 template_id: str,
                 user_data: str,
                 zone: str,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None):
        """
        :param str zone: The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "affinity_group_ids", affinity_group_ids)
        pulumi.set(__self__, "deploy_target_id", deploy_target_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "elastic_ip_ids", elastic_ip_ids)
        pulumi.set(__self__, "instance_prefix", instance_prefix)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "key_pair", key_pair)
        pulumi.set(__self__, "network_ids", network_ids)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "user_data", user_data)
        pulumi.set(__self__, "zone", zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="affinityGroupIds")
    def affinity_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "affinity_group_ids")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> str:
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="elasticIpIds")
    def elastic_ip_ids(self) -> Sequence[str]:
        return pulumi.get(self, "elastic_ip_ids")

    @property
    @pulumi.getter(name="instancePrefix")
    def instance_prefix(self) -> str:
        return pulumi.get(self, "instance_prefix")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetInstancePoolListPoolInstanceResult']:
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def ipv6(self) -> bool:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="keyPair")
    def key_pair(self) -> str:
        return pulumi.get(self, "key_pair")

    @property
    @pulumi.getter(name="networkIds")
    def network_ids(self) -> Sequence[str]:
        return pulumi.get(self, "network_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> str:
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> str:
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstancePoolListPoolInstanceResult(dict):
    def __init__(__self__, *,
                 ipv6_address: str,
                 public_ip_address: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSKSClusterListClusterResult(dict):
    def __init__(__self__, *,
                 addons: Sequence[str],
                 aggregation_ca: str,
                 control_plane_ca: str,
                 created_at: str,
                 endpoint: str,
                 kubelet_ca: str,
                 nodepools: Sequence[str],
                 oidc: 'outputs.GetSKSClusterListClusterOidcResult',
                 state: str,
                 version: str,
                 zone: str,
                 auto_upgrade: Optional[bool] = None,
                 cni: Optional[str] = None,
                 description: Optional[str] = None,
                 exoscale_ccm: Optional[bool] = None,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 metrics_server: Optional[bool] = None,
                 name: Optional[str] = None,
                 service_level: Optional[str] = None):
        """
        :param str aggregation_ca: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str control_plane_ca: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str created_at: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str endpoint: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str kubelet_ca: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str state: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str version: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str zone: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param bool auto_upgrade: Match against this bool
        :param str cni: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str description: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param bool exoscale_ccm: Match against this bool
        :param str id: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param Mapping[str, str] labels: Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
        :param bool metrics_server: Match against this bool
        :param str name: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str service_level: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        pulumi.set(__self__, "addons", addons)
        pulumi.set(__self__, "aggregation_ca", aggregation_ca)
        pulumi.set(__self__, "control_plane_ca", control_plane_ca)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "kubelet_ca", kubelet_ca)
        pulumi.set(__self__, "nodepools", nodepools)
        pulumi.set(__self__, "oidc", oidc)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zone", zone)
        if auto_upgrade is not None:
            pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        if cni is not None:
            pulumi.set(__self__, "cni", cni)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exoscale_ccm is not None:
            pulumi.set(__self__, "exoscale_ccm", exoscale_ccm)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metrics_server is not None:
            pulumi.set(__self__, "metrics_server", metrics_server)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_level is not None:
            pulumi.set(__self__, "service_level", service_level)

    @property
    @pulumi.getter
    def addons(self) -> Sequence[str]:
        return pulumi.get(self, "addons")

    @property
    @pulumi.getter(name="aggregationCa")
    def aggregation_ca(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "aggregation_ca")

    @property
    @pulumi.getter(name="controlPlaneCa")
    def control_plane_ca(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "control_plane_ca")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kubeletCa")
    def kubelet_ca(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "kubelet_ca")

    @property
    @pulumi.getter
    def nodepools(self) -> Sequence[str]:
        return pulumi.get(self, "nodepools")

    @property
    @pulumi.getter
    def oidc(self) -> 'outputs.GetSKSClusterListClusterOidcResult':
        return pulumi.get(self, "oidc")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> Optional[bool]:
        """
        Match against this bool
        """
        return pulumi.get(self, "auto_upgrade")

    @property
    @pulumi.getter
    def cni(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "cni")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="exoscaleCcm")
    def exoscale_ccm(self) -> Optional[bool]:
        """
        Match against this bool
        """
        return pulumi.get(self, "exoscale_ccm")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="metricsServer")
    def metrics_server(self) -> Optional[bool]:
        """
        Match against this bool
        """
        return pulumi.get(self, "metrics_server")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceLevel")
    def service_level(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "service_level")


@pulumi.output_type
class GetSKSClusterListClusterOidcResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claim: Optional[str] = None,
                 groups_prefix: Optional[str] = None,
                 required_claim: Optional[Mapping[str, str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[str]:
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class GetSKSClusterOidcResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claim: Optional[str] = None,
                 groups_prefix: Optional[str] = None,
                 required_claim: Optional[Mapping[str, str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        """
        :param str client_id: The OpenID client ID.
        :param str issuer_url: The OpenID provider URL.
        :param str groups_claim: An OpenID JWT claim to use as the user's group.
        :param str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param str username_claim: An OpenID JWT claim to use as the user name.
        :param str username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class GetSKSNodepoolListNodepoolResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 created_at: str,
                 instance_pool_id: str,
                 state: str,
                 template_id: str,
                 version: str,
                 zone: str,
                 anti_affinity_group_ids: Optional[Sequence[str]] = None,
                 deploy_target_id: Optional[str] = None,
                 description: Optional[str] = None,
                 disk_size: Optional[int] = None,
                 id: Optional[str] = None,
                 instance_prefix: Optional[str] = None,
                 instance_type: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 private_network_ids: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 size: Optional[int] = None,
                 taints: Optional[Mapping[str, str]] = None):
        """
        :param str cluster_id: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str created_at: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str instance_pool_id: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str state: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str template_id: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str version: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str zone: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str deploy_target_id: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str description: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param int disk_size: Match against this int
        :param str id: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str instance_prefix: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param str instance_type: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param Mapping[str, str] labels: Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
        :param str name: Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        :param int size: Match against this int
        :param Mapping[str, str] taints: Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zone", zone)
        if anti_affinity_group_ids is not None:
            pulumi.set(__self__, "anti_affinity_group_ids", anti_affinity_group_ids)
        if deploy_target_id is not None:
            pulumi.set(__self__, "deploy_target_id", deploy_target_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_prefix is not None:
            pulumi.set(__self__, "instance_prefix", instance_prefix)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_network_ids is not None:
            pulumi.set(__self__, "private_network_ids", private_network_ids)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="antiAffinityGroupIds")
    def anti_affinity_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "anti_affinity_group_ids")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        """
        Match against this int
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instancePrefix")
    def instance_prefix(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "instance_prefix")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Match against this string. If you supply a string that begins and ends with a "/" it will be matched as a regex.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "private_network_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        Match against this int
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Mapping[str, str]]:
        """
        Match against key/values. Keys are matched exactly, while values may be matched as a regex if you supply a string that begins and ends with "/"
        """
        return pulumi.get(self, "taints")


