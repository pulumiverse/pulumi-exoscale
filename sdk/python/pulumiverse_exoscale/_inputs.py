# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'ComputeInstanceNetworkInterfaceArgs',
    'DatabaseKafkaArgs',
    'DatabaseMysqlArgs',
    'DatabaseOpensearchArgs',
    'DatabaseOpensearchDashboardsArgs',
    'DatabaseOpensearchIndexPatternArgs',
    'DatabaseOpensearchIndexTemplateArgs',
    'DatabasePgArgs',
    'DatabaseRedisArgs',
    'ElasticIPHealthcheckArgs',
    'InstancePoolInstanceArgs',
    'NLBServiceHealthcheckArgs',
    'SKSClusterOidcArgs',
    'SecurityGroupRulesEgressArgs',
    'SecurityGroupRulesIngressArgs',
    'GetDomainRecordFilterArgs',
    'GetSKSClusterOidcArgs',
]

@pulumi.input_type
class ComputeInstanceNetworkInterfaceArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[str],
                 ip_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network_id: The exoscale*private*network (ID) to attach to the instance.
        :param pulumi.Input[str] ip_address: The IPv4 address to request as static DHCP lease if the network interface is attached to a *managed* private network.
        """
        pulumi.set(__self__, "network_id", network_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[str]:
        """
        The exoscale*private*network (ID) to attach to the instance.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv4 address to request as static DHCP lease if the network interface is attached to a *managed* private network.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)


@pulumi.input_type
class DatabaseKafkaArgs:
    def __init__(__self__, *,
                 enable_cert_auth: Optional[pulumi.Input[bool]] = None,
                 enable_kafka_connect: Optional[pulumi.Input[bool]] = None,
                 enable_kafka_rest: Optional[pulumi.Input[bool]] = None,
                 enable_sasl_auth: Optional[pulumi.Input[bool]] = None,
                 enable_schema_registry: Optional[pulumi.Input[bool]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kafka_connect_settings: Optional[pulumi.Input[str]] = None,
                 kafka_rest_settings: Optional[pulumi.Input[str]] = None,
                 kafka_settings: Optional[pulumi.Input[str]] = None,
                 schema_registry_settings: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable_cert_auth: Enable certificate-based authentication method.
        :param pulumi.Input[bool] enable_kafka_connect: Enable Kafka Connect.
        :param pulumi.Input[bool] enable_kafka_rest: Enable Kafka REST.
        :param pulumi.Input[bool] enable_sasl_auth: Enable SASL-based authentication method.
        :param pulumi.Input[bool] enable_schema_registry: Enable Schema Registry.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[str] kafka_connect_settings: Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        :param pulumi.Input[str] kafka_rest_settings: Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        :param pulumi.Input[str] kafka_settings: Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        :param pulumi.Input[str] schema_registry_settings: Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        :param pulumi.Input[str] version: Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        if enable_cert_auth is not None:
            pulumi.set(__self__, "enable_cert_auth", enable_cert_auth)
        if enable_kafka_connect is not None:
            pulumi.set(__self__, "enable_kafka_connect", enable_kafka_connect)
        if enable_kafka_rest is not None:
            pulumi.set(__self__, "enable_kafka_rest", enable_kafka_rest)
        if enable_sasl_auth is not None:
            pulumi.set(__self__, "enable_sasl_auth", enable_sasl_auth)
        if enable_schema_registry is not None:
            pulumi.set(__self__, "enable_schema_registry", enable_schema_registry)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect_settings is not None:
            pulumi.set(__self__, "kafka_connect_settings", kafka_connect_settings)
        if kafka_rest_settings is not None:
            pulumi.set(__self__, "kafka_rest_settings", kafka_rest_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if schema_registry_settings is not None:
            pulumi.set(__self__, "schema_registry_settings", schema_registry_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableCertAuth")
    def enable_cert_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable certificate-based authentication method.
        """
        return pulumi.get(self, "enable_cert_auth")

    @enable_cert_auth.setter
    def enable_cert_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_cert_auth", value)

    @property
    @pulumi.getter(name="enableKafkaConnect")
    def enable_kafka_connect(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Kafka Connect.
        """
        return pulumi.get(self, "enable_kafka_connect")

    @enable_kafka_connect.setter
    def enable_kafka_connect(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_kafka_connect", value)

    @property
    @pulumi.getter(name="enableKafkaRest")
    def enable_kafka_rest(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Kafka REST.
        """
        return pulumi.get(self, "enable_kafka_rest")

    @enable_kafka_rest.setter
    def enable_kafka_rest(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_kafka_rest", value)

    @property
    @pulumi.getter(name="enableSaslAuth")
    def enable_sasl_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable SASL-based authentication method.
        """
        return pulumi.get(self, "enable_sasl_auth")

    @enable_sasl_auth.setter
    def enable_sasl_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_sasl_auth", value)

    @property
    @pulumi.getter(name="enableSchemaRegistry")
    def enable_schema_registry(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Schema Registry.
        """
        return pulumi.get(self, "enable_schema_registry")

    @enable_schema_registry.setter
    def enable_schema_registry(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_schema_registry", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="kafkaConnectSettings")
    def kafka_connect_settings(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        return pulumi.get(self, "kafka_connect_settings")

    @kafka_connect_settings.setter
    def kafka_connect_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_connect_settings", value)

    @property
    @pulumi.getter(name="kafkaRestSettings")
    def kafka_rest_settings(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        return pulumi.get(self, "kafka_rest_settings")

    @kafka_rest_settings.setter
    def kafka_rest_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_rest_settings", value)

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        return pulumi.get(self, "kafka_settings")

    @kafka_settings.setter
    def kafka_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_settings", value)

    @property
    @pulumi.getter(name="schemaRegistrySettings")
    def schema_registry_settings(self) -> Optional[pulumi.Input[str]]:
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        return pulumi.get(self, "schema_registry_settings")

    @schema_registry_settings.setter
    def schema_registry_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema_registry_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class DatabaseMysqlArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[str]] = None,
                 admin_username: Optional[pulumi.Input[str]] = None,
                 backup_schedule: Optional[pulumi.Input[str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mysql_settings: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A custom administrator account password (may only be set at creation time).
        :param pulumi.Input[str] admin_username: A custom administrator account username (may only be set at creation time).
        :param pulumi.Input[str] backup_schedule: The automated backup schedule (`HH:MM`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[str] mysql_settings: MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        :param pulumi.Input[str] version: MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if mysql_settings is not None:
            pulumi.set(__self__, "mysql_settings", mysql_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[pulumi.Input[str]]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @backup_schedule.setter
    def backup_schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_schedule", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional[pulumi.Input[str]]:
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        return pulumi.get(self, "mysql_settings")

    @mysql_settings.setter
    def mysql_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mysql_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class DatabaseOpensearchArgs:
    def __init__(__self__, *,
                 dashboards: Optional[pulumi.Input['DatabaseOpensearchDashboardsArgs']] = None,
                 fork_from_service: Optional[pulumi.Input[str]] = None,
                 index_patterns: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]]] = None,
                 index_template: Optional[pulumi.Input['DatabaseOpensearchIndexTemplateArgs']] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 keep_index_refresh_interval: Optional[pulumi.Input[bool]] = None,
                 max_index_count: Optional[pulumi.Input[int]] = None,
                 recovery_backup_name: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] fork_from_service: ❗ Service name
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]] index_patterns: (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        :param pulumi.Input['DatabaseOpensearchIndexTemplateArgs'] index_template: Template settings for all new indexes
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]`
        :param pulumi.Input[bool] keep_index_refresh_interval: Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param pulumi.Input[int] max_index_count: Maximum number of indexes to keep (Minimum value is `0`)
        :param pulumi.Input[str] recovery_backup_name: ❗
        :param pulumi.Input[str] settings: OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        :param pulumi.Input[str] version: ❗ OpenSearch major version.
        """
        if dashboards is not None:
            pulumi.set(__self__, "dashboards", dashboards)
        if fork_from_service is not None:
            pulumi.set(__self__, "fork_from_service", fork_from_service)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if recovery_backup_name is not None:
            pulumi.set(__self__, "recovery_backup_name", recovery_backup_name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def dashboards(self) -> Optional[pulumi.Input['DatabaseOpensearchDashboardsArgs']]:
        return pulumi.get(self, "dashboards")

    @dashboards.setter
    def dashboards(self, value: Optional[pulumi.Input['DatabaseOpensearchDashboardsArgs']]):
        pulumi.set(self, "dashboards", value)

    @property
    @pulumi.getter(name="forkFromService")
    def fork_from_service(self) -> Optional[pulumi.Input[str]]:
        """
        ❗ Service name
        """
        return pulumi.get(self, "fork_from_service")

    @fork_from_service.setter
    def fork_from_service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fork_from_service", value)

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]]]:
        """
        (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        """
        return pulumi.get(self, "index_patterns")

    @index_patterns.setter
    def index_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]]]):
        pulumi.set(self, "index_patterns", value)

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional[pulumi.Input['DatabaseOpensearchIndexTemplateArgs']]:
        """
        Template settings for all new indexes
        """
        return pulumi.get(self, "index_template")

    @index_template.setter
    def index_template(self, value: Optional[pulumi.Input['DatabaseOpensearchIndexTemplateArgs']]):
        pulumi.set(self, "index_template", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]`
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[pulumi.Input[bool]]:
        """
        Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @keep_index_refresh_interval.setter
    def keep_index_refresh_interval(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_index_refresh_interval", value)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of indexes to keep (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @max_index_count.setter
    def max_index_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_index_count", value)

    @property
    @pulumi.getter(name="recoveryBackupName")
    def recovery_backup_name(self) -> Optional[pulumi.Input[str]]:
        """
        ❗
        """
        return pulumi.get(self, "recovery_backup_name")

    @recovery_backup_name.setter
    def recovery_backup_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recovery_backup_name", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[str]]:
        """
        OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        ❗ OpenSearch major version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class DatabaseOpensearchDashboardsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 max_old_space_size: Optional[pulumi.Input[int]] = None,
                 request_timeout: Optional[pulumi.Input[int]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_old_space_size")

    @max_old_space_size.setter
    def max_old_space_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_old_space_size", value)

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "request_timeout")

    @request_timeout.setter
    def request_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "request_timeout", value)


@pulumi.input_type
class DatabaseOpensearchIndexPatternArgs:
    def __init__(__self__, *,
                 max_index_count: Optional[pulumi.Input[int]] = None,
                 pattern: Optional[pulumi.Input[str]] = None,
                 sorting_algorithm: Optional[pulumi.Input[str]] = None):
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if sorting_algorithm is not None:
            pulumi.set(__self__, "sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_index_count")

    @max_index_count.setter
    def max_index_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_index_count", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sorting_algorithm")

    @sorting_algorithm.setter
    def sorting_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sorting_algorithm", value)


@pulumi.input_type
class DatabaseOpensearchIndexTemplateArgs:
    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[pulumi.Input[int]] = None,
                 number_of_replicas: Optional[pulumi.Input[int]] = None,
                 number_of_shards: Optional[pulumi.Input[int]] = None):
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mapping_nested_objects_limit")

    @mapping_nested_objects_limit.setter
    def mapping_nested_objects_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mapping_nested_objects_limit", value)

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number_of_replicas")

    @number_of_replicas.setter
    def number_of_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_replicas", value)

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number_of_shards")

    @number_of_shards.setter
    def number_of_shards(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_shards", value)


@pulumi.input_type
class DatabasePgArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[str]] = None,
                 admin_username: Optional[pulumi.Input[str]] = None,
                 backup_schedule: Optional[pulumi.Input[str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pg_settings: Optional[pulumi.Input[str]] = None,
                 pgbouncer_settings: Optional[pulumi.Input[str]] = None,
                 pglookout_settings: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A custom administrator account password (may only be set at creation time).
        :param pulumi.Input[str] admin_username: A custom administrator account username (may only be set at creation time).
        :param pulumi.Input[str] backup_schedule: The automated backup schedule (`HH:MM`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[str] pg_settings: PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        :param pulumi.Input[str] pgbouncer_settings: PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        :param pulumi.Input[str] pglookout_settings: pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        :param pulumi.Input[str] version: PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if pg_settings is not None:
            pulumi.set(__self__, "pg_settings", pg_settings)
        if pgbouncer_settings is not None:
            pulumi.set(__self__, "pgbouncer_settings", pgbouncer_settings)
        if pglookout_settings is not None:
            pulumi.set(__self__, "pglookout_settings", pglookout_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[pulumi.Input[str]]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @backup_schedule.setter
    def backup_schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_schedule", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="pgSettings")
    def pg_settings(self) -> Optional[pulumi.Input[str]]:
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        return pulumi.get(self, "pg_settings")

    @pg_settings.setter
    def pg_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pg_settings", value)

    @property
    @pulumi.getter(name="pgbouncerSettings")
    def pgbouncer_settings(self) -> Optional[pulumi.Input[str]]:
        """
        PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        """
        return pulumi.get(self, "pgbouncer_settings")

    @pgbouncer_settings.setter
    def pgbouncer_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pgbouncer_settings", value)

    @property
    @pulumi.getter(name="pglookoutSettings")
    def pglookout_settings(self) -> Optional[pulumi.Input[str]]:
        """
        pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        """
        return pulumi.get(self, "pglookout_settings")

    @pglookout_settings.setter
    def pglookout_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pglookout_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class DatabaseRedisArgs:
    def __init__(__self__, *,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 redis_settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[str] redis_settings: Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if redis_settings is not None:
            pulumi.set(__self__, "redis_settings", redis_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="redisSettings")
    def redis_settings(self) -> Optional[pulumi.Input[str]]:
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        return pulumi.get(self, "redis_settings")

    @redis_settings.setter
    def redis_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redis_settings", value)


@pulumi.input_type
class ElasticIPHealthcheckArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 port: pulumi.Input[int],
                 interval: Optional[pulumi.Input[int]] = None,
                 strikes_fail: Optional[pulumi.Input[int]] = None,
                 strikes_ok: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 tls_skip_verify: Optional[pulumi.Input[bool]] = None,
                 tls_sni: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: The healthcheck mode (`tcp`, `http` or `https`; may only be set at creation time).
        :param pulumi.Input[int] port: The healthcheck target port (must be between `1` and `65535`).
        :param pulumi.Input[int] interval: The healthcheck interval (seconds; must be between `5` and `300`; default: `10`).
        :param pulumi.Input[int] strikes_fail: The number of failed healthcheck attempts before considering the target unhealthy (must be between `1` and `20`; default: `2`).
        :param pulumi.Input[int] strikes_ok: The number of successful healthcheck attempts before considering the target healthy (must be between `1` and `20`; default: `3`).
        :param pulumi.Input[int] timeout: The time before considering a healthcheck probing failed (seconds; must be between `2` and `60`; default: `3`).
        :param pulumi.Input[bool] tls_skip_verify: Disable TLS certificate verification for healthcheck in `https` mode (boolean; default: `false`).
        :param pulumi.Input[str] tls_sni: The healthcheck server name to present with SNI in `https` mode.
        :param pulumi.Input[str] uri: The healthcheck target URI (required in `http(s)` modes).
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if strikes_fail is not None:
            pulumi.set(__self__, "strikes_fail", strikes_fail)
        if strikes_ok is not None:
            pulumi.set(__self__, "strikes_ok", strikes_ok)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        The healthcheck mode (`tcp`, `http` or `https`; may only be set at creation time).
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The healthcheck target port (must be between `1` and `65535`).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        The healthcheck interval (seconds; must be between `5` and `300`; default: `10`).
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> Optional[pulumi.Input[int]]:
        """
        The number of failed healthcheck attempts before considering the target unhealthy (must be between `1` and `20`; default: `2`).
        """
        return pulumi.get(self, "strikes_fail")

    @strikes_fail.setter
    def strikes_fail(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "strikes_fail", value)

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> Optional[pulumi.Input[int]]:
        """
        The number of successful healthcheck attempts before considering the target healthy (must be between `1` and `20`; default: `3`).
        """
        return pulumi.get(self, "strikes_ok")

    @strikes_ok.setter
    def strikes_ok(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "strikes_ok", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The time before considering a healthcheck probing failed (seconds; must be between `2` and `60`; default: `3`).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate verification for healthcheck in `https` mode (boolean; default: `false`).
        """
        return pulumi.get(self, "tls_skip_verify")

    @tls_skip_verify.setter
    def tls_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_skip_verify", value)

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[pulumi.Input[str]]:
        """
        The healthcheck server name to present with SNI in `https` mode.
        """
        return pulumi.get(self, "tls_sni")

    @tls_sni.setter
    def tls_sni(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_sni", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        The healthcheck target URI (required in `http(s)` modes).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class InstancePoolInstanceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 public_ip_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of this resource.
        :param pulumi.Input[str] ipv6_address: The instance (main network interface) IPv6 address.
        :param pulumi.Input[str] name: The instance name.
        :param pulumi.Input[str] public_ip_address: The instance (main network interface) IPv4 address.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        """
        The instance (main network interface) IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The instance name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The instance (main network interface) IPv4 address.
        """
        return pulumi.get(self, "public_ip_address")

    @public_ip_address.setter
    def public_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_ip_address", value)


@pulumi.input_type
class NLBServiceHealthcheckArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 interval: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 retries: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 tls_sni: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] port: The NLB service (TCP/UDP) port.
        :param pulumi.Input[int] interval: The healthcheck interval in seconds (default: `10`).
        :param pulumi.Input[str] mode: The healthcheck mode (`tcp`|`http`|`https`; default: `tcp`).
        :param pulumi.Input[int] retries: The healthcheck retries (default: `1`).
        :param pulumi.Input[int] timeout: The healthcheck timeout (seconds; default: `5`).
        :param pulumi.Input[str] tls_sni: The healthcheck TLS SNI server name (only if `mode` is `https`).
        :param pulumi.Input[str] uri: The healthcheck URI (must be set only if `mode` is `http(s)`).
        """
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The NLB service (TCP/UDP) port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        The healthcheck interval in seconds (default: `10`).
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The healthcheck mode (`tcp`|`http`|`https`; default: `tcp`).
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        The healthcheck retries (default: `1`).
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The healthcheck timeout (seconds; default: `5`).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[pulumi.Input[str]]:
        """
        The healthcheck TLS SNI server name (only if `mode` is `https`).
        """
        return pulumi.get(self, "tls_sni")

    @tls_sni.setter
    def tls_sni(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_sni", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        The healthcheck URI (must be set only if `mode` is `http(s)`).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class SKSClusterOidcArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 issuer_url: pulumi.Input[str],
                 groups_claim: Optional[pulumi.Input[str]] = None,
                 groups_prefix: Optional[pulumi.Input[str]] = None,
                 required_claim: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 username_claim: Optional[pulumi.Input[str]] = None,
                 username_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID client ID.
        :param pulumi.Input[str] issuer_url: The OpenID provider URL.
        :param pulumi.Input[str] groups_claim: An OpenID JWT claim to use as the user's group.
        :param pulumi.Input[str] groups_prefix: An OpenID prefix prepended to group claims.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param pulumi.Input[str] username_claim: An OpenID JWT claim to use as the user name.
        :param pulumi.Input[str] username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> pulumi.Input[str]:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "issuer_url", value)

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[pulumi.Input[str]]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @groups_claim.setter
    def groups_claim(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "groups_claim", value)

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @groups_prefix.setter
    def groups_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "groups_prefix", value)

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @required_claim.setter
    def required_claim(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "required_claim", value)

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[pulumi.Input[str]]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @username_claim.setter
    def username_claim(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username_claim", value)

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")

    @username_prefix.setter
    def username_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username_prefix", value)


@pulumi.input_type
class SecurityGroupRulesEgressArgs:
    def __init__(__self__, *,
                 cidr_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 icmp_code: Optional[pulumi.Input[int]] = None,
                 icmp_type: Optional[pulumi.Input[int]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 user_security_group_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidr_lists: A list of (`INGRESS`) source / (`EGRESS`) destination IP subnet (in CIDR notation) to match.
        :param pulumi.Input[str] description: A free-form text describing the block.
        :param pulumi.Input[int] icmp_code: An ICMP/ICMPv6 type/code to match.
        :param pulumi.Input[int] icmp_type: An ICMP/ICMPv6 type/code to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ports: A list of ports or port ranges (`<start_port>-<end_port>`).
        :param pulumi.Input[str] protocol: The network protocol to match (`TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` or `ALL`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_security_group_lists: A list of source (for ingress)/destination (for egress) identified by a security group.
        """
        if cidr_lists is not None:
            pulumi.set(__self__, "cidr_lists", cidr_lists)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if user_security_group_lists is not None:
            pulumi.set(__self__, "user_security_group_lists", user_security_group_lists)

    @property
    @pulumi.getter(name="cidrLists")
    def cidr_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of (`INGRESS`) source / (`EGRESS`) destination IP subnet (in CIDR notation) to match.
        """
        return pulumi.get(self, "cidr_lists")

    @cidr_lists.setter
    def cidr_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cidr_lists", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A free-form text describing the block.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[int]]:
        """
        An ICMP/ICMPv6 type/code to match.
        """
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[int]]:
        """
        An ICMP/ICMPv6 type/code to match.
        """
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of ports or port ranges (`<start_port>-<end_port>`).
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The network protocol to match (`TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` or `ALL`).
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="userSecurityGroupLists")
    def user_security_group_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of source (for ingress)/destination (for egress) identified by a security group.
        """
        return pulumi.get(self, "user_security_group_lists")

    @user_security_group_lists.setter
    def user_security_group_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_security_group_lists", value)


@pulumi.input_type
class SecurityGroupRulesIngressArgs:
    def __init__(__self__, *,
                 cidr_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 icmp_code: Optional[pulumi.Input[int]] = None,
                 icmp_type: Optional[pulumi.Input[int]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 user_security_group_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidr_lists: A list of (`INGRESS`) source / (`EGRESS`) destination IP subnet (in CIDR notation) to match.
        :param pulumi.Input[str] description: A free-form text describing the block.
        :param pulumi.Input[int] icmp_code: An ICMP/ICMPv6 type/code to match.
        :param pulumi.Input[int] icmp_type: An ICMP/ICMPv6 type/code to match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ports: A list of ports or port ranges (`<start_port>-<end_port>`).
        :param pulumi.Input[str] protocol: The network protocol to match (`TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` or `ALL`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_security_group_lists: A list of source (for ingress)/destination (for egress) identified by a security group.
        """
        if cidr_lists is not None:
            pulumi.set(__self__, "cidr_lists", cidr_lists)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if user_security_group_lists is not None:
            pulumi.set(__self__, "user_security_group_lists", user_security_group_lists)

    @property
    @pulumi.getter(name="cidrLists")
    def cidr_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of (`INGRESS`) source / (`EGRESS`) destination IP subnet (in CIDR notation) to match.
        """
        return pulumi.get(self, "cidr_lists")

    @cidr_lists.setter
    def cidr_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cidr_lists", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A free-form text describing the block.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[int]]:
        """
        An ICMP/ICMPv6 type/code to match.
        """
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[int]]:
        """
        An ICMP/ICMPv6 type/code to match.
        """
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of ports or port ranges (`<start_port>-<end_port>`).
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The network protocol to match (`TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` or `ALL`).
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="userSecurityGroupLists")
    def user_security_group_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of source (for ingress)/destination (for egress) identified by a security group.
        """
        return pulumi.get(self, "user_security_group_lists")

    @user_security_group_lists.setter
    def user_security_group_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_security_group_lists", value)


@pulumi.input_type
class GetDomainRecordFilterArgs:
    def __init__(__self__, *,
                 content_regex: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 record_type: Optional[str] = None):
        """
        :param str content_regex: A regular expression to match the record content.
        :param str id: The record ID to match.
        :param str name: The domain record name to match.
        :param str record_type: The record type to match.
        """
        if content_regex is not None:
            pulumi.set(__self__, "content_regex", content_regex)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)

    @property
    @pulumi.getter(name="contentRegex")
    def content_regex(self) -> Optional[str]:
        """
        A regular expression to match the record content.
        """
        return pulumi.get(self, "content_regex")

    @content_regex.setter
    def content_regex(self, value: Optional[str]):
        pulumi.set(self, "content_regex", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The record ID to match.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The domain record name to match.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        """
        The record type to match.
        """
        return pulumi.get(self, "record_type")

    @record_type.setter
    def record_type(self, value: Optional[str]):
        pulumi.set(self, "record_type", value)


@pulumi.input_type
class GetSKSClusterOidcArgs:
    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claim: Optional[str] = None,
                 groups_prefix: Optional[str] = None,
                 required_claim: Optional[Mapping[str, str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        """
        :param str client_id: The OpenID client ID.
        :param str issuer_url: The OpenID provider URL.
        :param str groups_claim: An OpenID JWT claim to use as the user's group.
        :param str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param str username_claim: An OpenID JWT claim to use as the user name.
        :param str username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: str):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: str):
        pulumi.set(self, "issuer_url", value)

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @groups_claim.setter
    def groups_claim(self, value: Optional[str]):
        pulumi.set(self, "groups_claim", value)

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @groups_prefix.setter
    def groups_prefix(self, value: Optional[str]):
        pulumi.set(self, "groups_prefix", value)

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @required_claim.setter
    def required_claim(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "required_claim", value)

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @username_claim.setter
    def username_claim(self, value: Optional[str]):
        pulumi.set(self, "username_claim", value)

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")

    @username_prefix.setter
    def username_prefix(self, value: Optional[str]):
        pulumi.set(self, "username_prefix", value)


