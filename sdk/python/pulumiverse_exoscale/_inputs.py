# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'BlockStorageVolumeSnapshotTargetArgs',
    'BlockStorageVolumeSnapshotTargetArgsDict',
    'BlockStorageVolumeSnapshotTimeoutsArgs',
    'BlockStorageVolumeSnapshotTimeoutsArgsDict',
    'BlockStorageVolumeSnapshotVolumeArgs',
    'BlockStorageVolumeSnapshotVolumeArgsDict',
    'BlockStorageVolumeTimeoutsArgs',
    'BlockStorageVolumeTimeoutsArgsDict',
    'ComputeInstanceNetworkInterfaceArgs',
    'ComputeInstanceNetworkInterfaceArgsDict',
    'DatabaseGrafanaArgs',
    'DatabaseGrafanaArgsDict',
    'DatabaseKafkaArgs',
    'DatabaseKafkaArgsDict',
    'DatabaseMysqlArgs',
    'DatabaseMysqlArgsDict',
    'DatabaseOpensearchArgs',
    'DatabaseOpensearchArgsDict',
    'DatabaseOpensearchDashboardsArgs',
    'DatabaseOpensearchDashboardsArgsDict',
    'DatabaseOpensearchIndexPatternArgs',
    'DatabaseOpensearchIndexPatternArgsDict',
    'DatabaseOpensearchIndexTemplateArgs',
    'DatabaseOpensearchIndexTemplateArgsDict',
    'DatabasePgArgs',
    'DatabasePgArgsDict',
    'DatabaseRedisArgs',
    'DatabaseRedisArgsDict',
    'DatabaseTimeoutsArgs',
    'DatabaseTimeoutsArgsDict',
    'DatabaseValkeyArgs',
    'DatabaseValkeyArgsDict',
    'DbaasGrafanaArgs',
    'DbaasGrafanaArgsDict',
    'DbaasKafkaArgs',
    'DbaasKafkaArgsDict',
    'DbaasKafkaUserTimeoutsArgs',
    'DbaasKafkaUserTimeoutsArgsDict',
    'DbaasMysqlArgs',
    'DbaasMysqlArgsDict',
    'DbaasMysqlDatabaseTimeoutsArgs',
    'DbaasMysqlDatabaseTimeoutsArgsDict',
    'DbaasMysqlUserTimeoutsArgs',
    'DbaasMysqlUserTimeoutsArgsDict',
    'DbaasOpensearchArgs',
    'DbaasOpensearchArgsDict',
    'DbaasOpensearchDashboardsArgs',
    'DbaasOpensearchDashboardsArgsDict',
    'DbaasOpensearchIndexPatternArgs',
    'DbaasOpensearchIndexPatternArgsDict',
    'DbaasOpensearchIndexTemplateArgs',
    'DbaasOpensearchIndexTemplateArgsDict',
    'DbaasOpensearchUserTimeoutsArgs',
    'DbaasOpensearchUserTimeoutsArgsDict',
    'DbaasPgArgs',
    'DbaasPgArgsDict',
    'DbaasPgDatabaseTimeoutsArgs',
    'DbaasPgDatabaseTimeoutsArgsDict',
    'DbaasPgUserTimeoutsArgs',
    'DbaasPgUserTimeoutsArgsDict',
    'DbaasRedisArgs',
    'DbaasRedisArgsDict',
    'DbaasTimeoutsArgs',
    'DbaasTimeoutsArgsDict',
    'DbaasValkeyArgs',
    'DbaasValkeyArgsDict',
    'ElasticIpHealthcheckArgs',
    'ElasticIpHealthcheckArgsDict',
    'IamApiKeyTimeoutsArgs',
    'IamApiKeyTimeoutsArgsDict',
    'IamOrgPolicyServicesArgs',
    'IamOrgPolicyServicesArgsDict',
    'IamOrgPolicyServicesRuleArgs',
    'IamOrgPolicyServicesRuleArgsDict',
    'IamOrgPolicyTimeoutsArgs',
    'IamOrgPolicyTimeoutsArgsDict',
    'IamRolePolicyArgs',
    'IamRolePolicyArgsDict',
    'IamRolePolicyServicesArgs',
    'IamRolePolicyServicesArgsDict',
    'IamRolePolicyServicesRuleArgs',
    'IamRolePolicyServicesRuleArgsDict',
    'IamRoleTimeoutsArgs',
    'IamRoleTimeoutsArgsDict',
    'InstancePoolInstanceArgs',
    'InstancePoolInstanceArgsDict',
    'NlbServiceHealthcheckArgs',
    'NlbServiceHealthcheckArgsDict',
    'SksClusterOidcArgs',
    'SksClusterOidcArgsDict',
    'SksNodepoolKubeletImageGcArgs',
    'SksNodepoolKubeletImageGcArgsDict',
    'SosBucketPolicyTimeoutsArgs',
    'SosBucketPolicyTimeoutsArgsDict',
    'GetBlockStorageVolumeSnapshotTimeoutsArgs',
    'GetBlockStorageVolumeSnapshotTimeoutsArgsDict',
    'GetBlockStorageVolumeTimeoutsArgs',
    'GetBlockStorageVolumeTimeoutsArgsDict',
    'GetDatabaseUriTimeoutsArgs',
    'GetDatabaseUriTimeoutsArgsDict',
    'GetDomainRecordFilterArgs',
    'GetDomainRecordFilterArgsDict',
    'GetIamApiKeyTimeoutsArgs',
    'GetIamApiKeyTimeoutsArgsDict',
    'GetIamOrgPolicyTimeoutsArgs',
    'GetIamOrgPolicyTimeoutsArgsDict',
    'GetIamRoleTimeoutsArgs',
    'GetIamRoleTimeoutsArgsDict',
    'GetNlbServiceListTimeoutsArgs',
    'GetNlbServiceListTimeoutsArgsDict',
    'GetSksClusterOidcArgs',
    'GetSksClusterOidcArgsDict',
    'GetSksNodepoolKubeletImageGcArgs',
    'GetSksNodepoolKubeletImageGcArgsDict',
    'GetSosBucketPolicyTimeoutsArgs',
    'GetSosBucketPolicyTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class BlockStorageVolumeSnapshotTargetArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Snapshot ID.
        """
elif False:
    BlockStorageVolumeSnapshotTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlockStorageVolumeSnapshotTargetArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: Snapshot ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Snapshot ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BlockStorageVolumeSnapshotTimeoutsArgsDict(TypedDict):
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    BlockStorageVolumeSnapshotTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlockStorageVolumeSnapshotTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)


if not MYPY:
    class BlockStorageVolumeSnapshotVolumeArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        Snapshot ID.
        """
elif False:
    BlockStorageVolumeSnapshotVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlockStorageVolumeSnapshotVolumeArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] id: Snapshot ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Snapshot ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BlockStorageVolumeTimeoutsArgsDict(TypedDict):
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    BlockStorageVolumeTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlockStorageVolumeTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)


if not MYPY:
    class ComputeInstanceNetworkInterfaceArgsDict(TypedDict):
        network_id: pulumi.Input[builtins.str]
        """
        The exoscale*private*network (ID) to attach to the instance.
        """
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The IPv4 address to request as static DHCP lease if the network interface is attached to a *managed* private network.
        """
        mac_address: NotRequired[pulumi.Input[builtins.str]]
        """
        MAC address
        """
elif False:
    ComputeInstanceNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceNetworkInterfaceArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[builtins.str],
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 mac_address: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] network_id: The exoscale*private*network (ID) to attach to the instance.
        :param pulumi.Input[builtins.str] ip_address: The IPv4 address to request as static DHCP lease if the network interface is attached to a *managed* private network.
        :param pulumi.Input[builtins.str] mac_address: MAC address
        """
        pulumi.set(__self__, "network_id", network_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[builtins.str]:
        """
        The exoscale*private*network (ID) to attach to the instance.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "network_id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The IPv4 address to request as static DHCP lease if the network interface is attached to a *managed* private network.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        MAC address
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mac_address", value)


if not MYPY:
    class DatabaseGrafanaArgsDict(TypedDict):
        grafana_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
elif False:
    DatabaseGrafanaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseGrafanaArgs:
    def __init__(__self__, *,
                 grafana_settings: Optional[pulumi.Input[builtins.str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] grafana_settings: Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        """
        if grafana_settings is not None:
            pulumi.set(__self__, "grafana_settings", grafana_settings)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)

    @property
    @pulumi.getter(name="grafanaSettings")
    def grafana_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        """
        return pulumi.get(self, "grafana_settings")

    @grafana_settings.setter
    def grafana_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "grafana_settings", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)


if not MYPY:
    class DatabaseKafkaArgsDict(TypedDict):
        enable_cert_auth: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable certificate-based authentication method.
        """
        enable_kafka_connect: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable Kafka Connect.
        """
        enable_kafka_rest: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable Kafka REST.
        """
        enable_sasl_auth: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable SASL-based authentication method.
        """
        enable_schema_registry: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable Schema Registry.
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        kafka_connect_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        kafka_rest_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        kafka_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        schema_registry_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
elif False:
    DatabaseKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseKafkaArgs:
    def __init__(__self__, *,
                 enable_cert_auth: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_kafka_connect: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_kafka_rest: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_sasl_auth: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_schema_registry: Optional[pulumi.Input[builtins.bool]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 kafka_connect_settings: Optional[pulumi.Input[builtins.str]] = None,
                 kafka_rest_settings: Optional[pulumi.Input[builtins.str]] = None,
                 kafka_settings: Optional[pulumi.Input[builtins.str]] = None,
                 schema_registry_settings: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enable_cert_auth: Enable certificate-based authentication method.
        :param pulumi.Input[builtins.bool] enable_kafka_connect: Enable Kafka Connect.
        :param pulumi.Input[builtins.bool] enable_kafka_rest: Enable Kafka REST.
        :param pulumi.Input[builtins.bool] enable_sasl_auth: Enable SASL-based authentication method.
        :param pulumi.Input[builtins.bool] enable_schema_registry: Enable Schema Registry.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[builtins.str] kafka_connect_settings: Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        :param pulumi.Input[builtins.str] kafka_rest_settings: Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        :param pulumi.Input[builtins.str] kafka_settings: Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        :param pulumi.Input[builtins.str] schema_registry_settings: Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        :param pulumi.Input[builtins.str] version: Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        if enable_cert_auth is not None:
            pulumi.set(__self__, "enable_cert_auth", enable_cert_auth)
        if enable_kafka_connect is not None:
            pulumi.set(__self__, "enable_kafka_connect", enable_kafka_connect)
        if enable_kafka_rest is not None:
            pulumi.set(__self__, "enable_kafka_rest", enable_kafka_rest)
        if enable_sasl_auth is not None:
            pulumi.set(__self__, "enable_sasl_auth", enable_sasl_auth)
        if enable_schema_registry is not None:
            pulumi.set(__self__, "enable_schema_registry", enable_schema_registry)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect_settings is not None:
            pulumi.set(__self__, "kafka_connect_settings", kafka_connect_settings)
        if kafka_rest_settings is not None:
            pulumi.set(__self__, "kafka_rest_settings", kafka_rest_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if schema_registry_settings is not None:
            pulumi.set(__self__, "schema_registry_settings", schema_registry_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableCertAuth")
    def enable_cert_auth(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable certificate-based authentication method.
        """
        return pulumi.get(self, "enable_cert_auth")

    @enable_cert_auth.setter
    def enable_cert_auth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_cert_auth", value)

    @property
    @pulumi.getter(name="enableKafkaConnect")
    def enable_kafka_connect(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable Kafka Connect.
        """
        return pulumi.get(self, "enable_kafka_connect")

    @enable_kafka_connect.setter
    def enable_kafka_connect(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_kafka_connect", value)

    @property
    @pulumi.getter(name="enableKafkaRest")
    def enable_kafka_rest(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable Kafka REST.
        """
        return pulumi.get(self, "enable_kafka_rest")

    @enable_kafka_rest.setter
    def enable_kafka_rest(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_kafka_rest", value)

    @property
    @pulumi.getter(name="enableSaslAuth")
    def enable_sasl_auth(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable SASL-based authentication method.
        """
        return pulumi.get(self, "enable_sasl_auth")

    @enable_sasl_auth.setter
    def enable_sasl_auth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_sasl_auth", value)

    @property
    @pulumi.getter(name="enableSchemaRegistry")
    def enable_schema_registry(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable Schema Registry.
        """
        return pulumi.get(self, "enable_schema_registry")

    @enable_schema_registry.setter
    def enable_schema_registry(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_schema_registry", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="kafkaConnectSettings")
    def kafka_connect_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        return pulumi.get(self, "kafka_connect_settings")

    @kafka_connect_settings.setter
    def kafka_connect_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kafka_connect_settings", value)

    @property
    @pulumi.getter(name="kafkaRestSettings")
    def kafka_rest_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        return pulumi.get(self, "kafka_rest_settings")

    @kafka_rest_settings.setter
    def kafka_rest_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kafka_rest_settings", value)

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        return pulumi.get(self, "kafka_settings")

    @kafka_settings.setter
    def kafka_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kafka_settings", value)

    @property
    @pulumi.getter(name="schemaRegistrySettings")
    def schema_registry_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        return pulumi.get(self, "schema_registry_settings")

    @schema_registry_settings.setter
    def schema_registry_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "schema_registry_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DatabaseMysqlArgsDict(TypedDict):
        admin_password: NotRequired[pulumi.Input[builtins.str]]
        """
        A custom administrator account password (may only be set at creation time).
        """
        admin_username: NotRequired[pulumi.Input[builtins.str]]
        """
        A custom administrator account username (may only be set at creation time).
        """
        backup_schedule: NotRequired[pulumi.Input[builtins.str]]
        """
        The automated backup schedule (`HH:MM`).
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        mysql_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
elif False:
    DatabaseMysqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseMysqlArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[builtins.str]] = None,
                 admin_username: Optional[pulumi.Input[builtins.str]] = None,
                 backup_schedule: Optional[pulumi.Input[builtins.str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 mysql_settings: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] admin_password: A custom administrator account password (may only be set at creation time).
        :param pulumi.Input[builtins.str] admin_username: A custom administrator account username (may only be set at creation time).
        :param pulumi.Input[builtins.str] backup_schedule: The automated backup schedule (`HH:MM`).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[builtins.str] mysql_settings: MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        :param pulumi.Input[builtins.str] version: MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if mysql_settings is not None:
            pulumi.set(__self__, "mysql_settings", mysql_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @backup_schedule.setter
    def backup_schedule(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backup_schedule", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        return pulumi.get(self, "mysql_settings")

    @mysql_settings.setter
    def mysql_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mysql_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DatabaseOpensearchArgsDict(TypedDict):
        dashboards: NotRequired[pulumi.Input['DatabaseOpensearchDashboardsArgsDict']]
        """
        OpenSearch Dashboards settings
        """
        fork_from_service: NotRequired[pulumi.Input[builtins.str]]
        """
        ❗ Service name
        """
        index_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgsDict']]]]
        """
        (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        """
        index_template: NotRequired[pulumi.Input['DatabaseOpensearchIndexTemplateArgsDict']]
        """
        Template settings for all new indexes
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        """
        keep_index_refresh_interval: NotRequired[pulumi.Input[builtins.bool]]
        """
        Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        max_index_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of indexes to keep (Minimum value is `0`)
        """
        recovery_backup_name: NotRequired[pulumi.Input[builtins.str]]
        """
        ❗ Name of a backup to recover from
        """
        settings: NotRequired[pulumi.Input[builtins.str]]
        """
        OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
elif False:
    DatabaseOpensearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseOpensearchArgs:
    def __init__(__self__, *,
                 dashboards: Optional[pulumi.Input['DatabaseOpensearchDashboardsArgs']] = None,
                 fork_from_service: Optional[pulumi.Input[builtins.str]] = None,
                 index_patterns: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]]] = None,
                 index_template: Optional[pulumi.Input['DatabaseOpensearchIndexTemplateArgs']] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 keep_index_refresh_interval: Optional[pulumi.Input[builtins.bool]] = None,
                 max_index_count: Optional[pulumi.Input[builtins.int]] = None,
                 recovery_backup_name: Optional[pulumi.Input[builtins.str]] = None,
                 settings: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['DatabaseOpensearchDashboardsArgs'] dashboards: OpenSearch Dashboards settings
        :param pulumi.Input[builtins.str] fork_from_service: ❗ Service name
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]] index_patterns: (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        :param pulumi.Input['DatabaseOpensearchIndexTemplateArgs'] index_template: Template settings for all new indexes
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        :param pulumi.Input[builtins.bool] keep_index_refresh_interval: Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param pulumi.Input[builtins.int] max_index_count: Maximum number of indexes to keep (Minimum value is `0`)
        :param pulumi.Input[builtins.str] recovery_backup_name: ❗ Name of a backup to recover from
        :param pulumi.Input[builtins.str] settings: OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        :param pulumi.Input[builtins.str] version: ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        if dashboards is not None:
            pulumi.set(__self__, "dashboards", dashboards)
        if fork_from_service is not None:
            pulumi.set(__self__, "fork_from_service", fork_from_service)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            warnings.warn("""This attribute is deprecated and is ignored""", DeprecationWarning)
            pulumi.log.warn("""max_index_count is deprecated: This attribute is deprecated and is ignored""")
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if recovery_backup_name is not None:
            pulumi.set(__self__, "recovery_backup_name", recovery_backup_name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def dashboards(self) -> Optional[pulumi.Input['DatabaseOpensearchDashboardsArgs']]:
        """
        OpenSearch Dashboards settings
        """
        return pulumi.get(self, "dashboards")

    @dashboards.setter
    def dashboards(self, value: Optional[pulumi.Input['DatabaseOpensearchDashboardsArgs']]):
        pulumi.set(self, "dashboards", value)

    @property
    @pulumi.getter(name="forkFromService")
    def fork_from_service(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ❗ Service name
        """
        return pulumi.get(self, "fork_from_service")

    @fork_from_service.setter
    def fork_from_service(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fork_from_service", value)

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]]]:
        """
        (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        """
        return pulumi.get(self, "index_patterns")

    @index_patterns.setter
    def index_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseOpensearchIndexPatternArgs']]]]):
        pulumi.set(self, "index_patterns", value)

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional[pulumi.Input['DatabaseOpensearchIndexTemplateArgs']]:
        """
        Template settings for all new indexes
        """
        return pulumi.get(self, "index_template")

    @index_template.setter
    def index_template(self, value: Optional[pulumi.Input['DatabaseOpensearchIndexTemplateArgs']]):
        pulumi.set(self, "index_template", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @keep_index_refresh_interval.setter
    def keep_index_refresh_interval(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "keep_index_refresh_interval", value)

    @property
    @pulumi.getter(name="maxIndexCount")
    @_utilities.deprecated("""This attribute is deprecated and is ignored""")
    def max_index_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of indexes to keep (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @max_index_count.setter
    def max_index_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_index_count", value)

    @property
    @pulumi.getter(name="recoveryBackupName")
    def recovery_backup_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ❗ Name of a backup to recover from
        """
        return pulumi.get(self, "recovery_backup_name")

    @recovery_backup_name.setter
    def recovery_backup_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "recovery_backup_name", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DatabaseOpensearchDashboardsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable OpenSearch Dashboards (default: true).
        """
        max_old_space_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        """
        request_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
elif False:
    DatabaseOpensearchDashboardsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseOpensearchDashboardsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_old_space_size: Optional[pulumi.Input[builtins.int]] = None,
                 request_timeout: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Enable or disable OpenSearch Dashboards (default: true).
        :param pulumi.Input[builtins.int] max_old_space_size: Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        :param pulumi.Input[builtins.int] request_timeout: Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable OpenSearch Dashboards (default: true).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        """
        return pulumi.get(self, "max_old_space_size")

    @max_old_space_size.setter
    def max_old_space_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_old_space_size", value)

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        return pulumi.get(self, "request_timeout")

    @request_timeout.setter
    def request_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "request_timeout", value)


if not MYPY:
    class DatabaseOpensearchIndexPatternArgsDict(TypedDict):
        max_index_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        """
        pattern: NotRequired[pulumi.Input[builtins.str]]
        """
        fnmatch pattern
        """
        sorting_algorithm: NotRequired[pulumi.Input[builtins.str]]
        """
        `alphabetical` or `creation_date`.
        """
elif False:
    DatabaseOpensearchIndexPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseOpensearchIndexPatternArgs:
    def __init__(__self__, *,
                 max_index_count: Optional[pulumi.Input[builtins.int]] = None,
                 pattern: Optional[pulumi.Input[builtins.str]] = None,
                 sorting_algorithm: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] max_index_count: Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        :param pulumi.Input[builtins.str] pattern: fnmatch pattern
        :param pulumi.Input[builtins.str] sorting_algorithm: `alphabetical` or `creation_date`.
        """
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if sorting_algorithm is not None:
            pulumi.set(__self__, "sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @max_index_count.setter
    def max_index_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_index_count", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        fnmatch pattern
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        `alphabetical` or `creation_date`.
        """
        return pulumi.get(self, "sorting_algorithm")

    @sorting_algorithm.setter
    def sorting_algorithm(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sorting_algorithm", value)


if not MYPY:
    class DatabaseOpensearchIndexTemplateArgsDict(TypedDict):
        mapping_nested_objects_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        """
        number_of_replicas: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        """
        number_of_shards: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
elif False:
    DatabaseOpensearchIndexTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseOpensearchIndexTemplateArgs:
    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[pulumi.Input[builtins.int]] = None,
                 number_of_replicas: Optional[pulumi.Input[builtins.int]] = None,
                 number_of_shards: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] mapping_nested_objects_limit: The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        :param pulumi.Input[builtins.int] number_of_replicas: The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        :param pulumi.Input[builtins.int] number_of_shards: The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        """
        return pulumi.get(self, "mapping_nested_objects_limit")

    @mapping_nested_objects_limit.setter
    def mapping_nested_objects_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "mapping_nested_objects_limit", value)

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        """
        return pulumi.get(self, "number_of_replicas")

    @number_of_replicas.setter
    def number_of_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "number_of_replicas", value)

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        return pulumi.get(self, "number_of_shards")

    @number_of_shards.setter
    def number_of_shards(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "number_of_shards", value)


if not MYPY:
    class DatabasePgArgsDict(TypedDict):
        admin_password: NotRequired[pulumi.Input[builtins.str]]
        """
        A custom administrator account password (may only be set at creation time).
        """
        admin_username: NotRequired[pulumi.Input[builtins.str]]
        """
        A custom administrator account username (may only be set at creation time).
        """
        backup_schedule: NotRequired[pulumi.Input[builtins.str]]
        """
        The automated backup schedule (`HH:MM`).
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        pg_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        pgbouncer_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        """
        pglookout_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
elif False:
    DatabasePgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabasePgArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[builtins.str]] = None,
                 admin_username: Optional[pulumi.Input[builtins.str]] = None,
                 backup_schedule: Optional[pulumi.Input[builtins.str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 pg_settings: Optional[pulumi.Input[builtins.str]] = None,
                 pgbouncer_settings: Optional[pulumi.Input[builtins.str]] = None,
                 pglookout_settings: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] admin_password: A custom administrator account password (may only be set at creation time).
        :param pulumi.Input[builtins.str] admin_username: A custom administrator account username (may only be set at creation time).
        :param pulumi.Input[builtins.str] backup_schedule: The automated backup schedule (`HH:MM`).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[builtins.str] pg_settings: PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        :param pulumi.Input[builtins.str] pgbouncer_settings: PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        :param pulumi.Input[builtins.str] pglookout_settings: pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        :param pulumi.Input[builtins.str] version: PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if pg_settings is not None:
            pulumi.set(__self__, "pg_settings", pg_settings)
        if pgbouncer_settings is not None:
            pulumi.set(__self__, "pgbouncer_settings", pgbouncer_settings)
        if pglookout_settings is not None:
            pulumi.set(__self__, "pglookout_settings", pglookout_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @backup_schedule.setter
    def backup_schedule(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backup_schedule", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="pgSettings")
    def pg_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        return pulumi.get(self, "pg_settings")

    @pg_settings.setter
    def pg_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pg_settings", value)

    @property
    @pulumi.getter(name="pgbouncerSettings")
    def pgbouncer_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        """
        return pulumi.get(self, "pgbouncer_settings")

    @pgbouncer_settings.setter
    def pgbouncer_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pgbouncer_settings", value)

    @property
    @pulumi.getter(name="pglookoutSettings")
    def pglookout_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        """
        return pulumi.get(self, "pglookout_settings")

    @pglookout_settings.setter
    def pglookout_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pglookout_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DatabaseRedisArgsDict(TypedDict):
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        redis_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
elif False:
    DatabaseRedisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseRedisArgs:
    def __init__(__self__, *,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 redis_settings: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[builtins.str] redis_settings: Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if redis_settings is not None:
            pulumi.set(__self__, "redis_settings", redis_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="redisSettings")
    def redis_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        return pulumi.get(self, "redis_settings")

    @redis_settings.setter
    def redis_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redis_settings", value)


if not MYPY:
    class DatabaseTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DatabaseTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class DatabaseValkeyArgsDict(TypedDict):
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        valkey_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Valkey configuration settings in JSON format (`exo dbaas type show valkey --settings=valkey` for reference).
        """
elif False:
    DatabaseValkeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseValkeyArgs:
    def __init__(__self__, *,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 valkey_settings: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[builtins.str] valkey_settings: Valkey configuration settings in JSON format (`exo dbaas type show valkey --settings=valkey` for reference).
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if valkey_settings is not None:
            pulumi.set(__self__, "valkey_settings", valkey_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="valkeySettings")
    def valkey_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Valkey configuration settings in JSON format (`exo dbaas type show valkey --settings=valkey` for reference).
        """
        return pulumi.get(self, "valkey_settings")

    @valkey_settings.setter
    def valkey_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "valkey_settings", value)


if not MYPY:
    class DbaasGrafanaArgsDict(TypedDict):
        grafana_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
elif False:
    DbaasGrafanaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasGrafanaArgs:
    def __init__(__self__, *,
                 grafana_settings: Optional[pulumi.Input[builtins.str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] grafana_settings: Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        """
        if grafana_settings is not None:
            pulumi.set(__self__, "grafana_settings", grafana_settings)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)

    @property
    @pulumi.getter(name="grafanaSettings")
    def grafana_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        """
        return pulumi.get(self, "grafana_settings")

    @grafana_settings.setter
    def grafana_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "grafana_settings", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)


if not MYPY:
    class DbaasKafkaArgsDict(TypedDict):
        enable_cert_auth: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable certificate-based authentication method.
        """
        enable_kafka_connect: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable Kafka Connect.
        """
        enable_kafka_rest: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable Kafka REST.
        """
        enable_sasl_auth: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable SASL-based authentication method.
        """
        enable_schema_registry: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable Schema Registry.
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        kafka_connect_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        kafka_rest_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        kafka_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        schema_registry_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
elif False:
    DbaasKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasKafkaArgs:
    def __init__(__self__, *,
                 enable_cert_auth: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_kafka_connect: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_kafka_rest: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_sasl_auth: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_schema_registry: Optional[pulumi.Input[builtins.bool]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 kafka_connect_settings: Optional[pulumi.Input[builtins.str]] = None,
                 kafka_rest_settings: Optional[pulumi.Input[builtins.str]] = None,
                 kafka_settings: Optional[pulumi.Input[builtins.str]] = None,
                 schema_registry_settings: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enable_cert_auth: Enable certificate-based authentication method.
        :param pulumi.Input[builtins.bool] enable_kafka_connect: Enable Kafka Connect.
        :param pulumi.Input[builtins.bool] enable_kafka_rest: Enable Kafka REST.
        :param pulumi.Input[builtins.bool] enable_sasl_auth: Enable SASL-based authentication method.
        :param pulumi.Input[builtins.bool] enable_schema_registry: Enable Schema Registry.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[builtins.str] kafka_connect_settings: Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        :param pulumi.Input[builtins.str] kafka_rest_settings: Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        :param pulumi.Input[builtins.str] kafka_settings: Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        :param pulumi.Input[builtins.str] schema_registry_settings: Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        :param pulumi.Input[builtins.str] version: Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        if enable_cert_auth is not None:
            pulumi.set(__self__, "enable_cert_auth", enable_cert_auth)
        if enable_kafka_connect is not None:
            pulumi.set(__self__, "enable_kafka_connect", enable_kafka_connect)
        if enable_kafka_rest is not None:
            pulumi.set(__self__, "enable_kafka_rest", enable_kafka_rest)
        if enable_sasl_auth is not None:
            pulumi.set(__self__, "enable_sasl_auth", enable_sasl_auth)
        if enable_schema_registry is not None:
            pulumi.set(__self__, "enable_schema_registry", enable_schema_registry)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect_settings is not None:
            pulumi.set(__self__, "kafka_connect_settings", kafka_connect_settings)
        if kafka_rest_settings is not None:
            pulumi.set(__self__, "kafka_rest_settings", kafka_rest_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if schema_registry_settings is not None:
            pulumi.set(__self__, "schema_registry_settings", schema_registry_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableCertAuth")
    def enable_cert_auth(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable certificate-based authentication method.
        """
        return pulumi.get(self, "enable_cert_auth")

    @enable_cert_auth.setter
    def enable_cert_auth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_cert_auth", value)

    @property
    @pulumi.getter(name="enableKafkaConnect")
    def enable_kafka_connect(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable Kafka Connect.
        """
        return pulumi.get(self, "enable_kafka_connect")

    @enable_kafka_connect.setter
    def enable_kafka_connect(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_kafka_connect", value)

    @property
    @pulumi.getter(name="enableKafkaRest")
    def enable_kafka_rest(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable Kafka REST.
        """
        return pulumi.get(self, "enable_kafka_rest")

    @enable_kafka_rest.setter
    def enable_kafka_rest(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_kafka_rest", value)

    @property
    @pulumi.getter(name="enableSaslAuth")
    def enable_sasl_auth(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable SASL-based authentication method.
        """
        return pulumi.get(self, "enable_sasl_auth")

    @enable_sasl_auth.setter
    def enable_sasl_auth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_sasl_auth", value)

    @property
    @pulumi.getter(name="enableSchemaRegistry")
    def enable_schema_registry(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable Schema Registry.
        """
        return pulumi.get(self, "enable_schema_registry")

    @enable_schema_registry.setter
    def enable_schema_registry(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_schema_registry", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="kafkaConnectSettings")
    def kafka_connect_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        return pulumi.get(self, "kafka_connect_settings")

    @kafka_connect_settings.setter
    def kafka_connect_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kafka_connect_settings", value)

    @property
    @pulumi.getter(name="kafkaRestSettings")
    def kafka_rest_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        return pulumi.get(self, "kafka_rest_settings")

    @kafka_rest_settings.setter
    def kafka_rest_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kafka_rest_settings", value)

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        return pulumi.get(self, "kafka_settings")

    @kafka_settings.setter
    def kafka_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kafka_settings", value)

    @property
    @pulumi.getter(name="schemaRegistrySettings")
    def schema_registry_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        return pulumi.get(self, "schema_registry_settings")

    @schema_registry_settings.setter
    def schema_registry_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "schema_registry_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DbaasKafkaUserTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DbaasKafkaUserTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasKafkaUserTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class DbaasMysqlArgsDict(TypedDict):
        admin_password: NotRequired[pulumi.Input[builtins.str]]
        """
        A custom administrator account password (may only be set at creation time).
        """
        admin_username: NotRequired[pulumi.Input[builtins.str]]
        """
        A custom administrator account username (may only be set at creation time).
        """
        backup_schedule: NotRequired[pulumi.Input[builtins.str]]
        """
        The automated backup schedule (`HH:MM`).
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        mysql_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
elif False:
    DbaasMysqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasMysqlArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[builtins.str]] = None,
                 admin_username: Optional[pulumi.Input[builtins.str]] = None,
                 backup_schedule: Optional[pulumi.Input[builtins.str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 mysql_settings: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] admin_password: A custom administrator account password (may only be set at creation time).
        :param pulumi.Input[builtins.str] admin_username: A custom administrator account username (may only be set at creation time).
        :param pulumi.Input[builtins.str] backup_schedule: The automated backup schedule (`HH:MM`).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[builtins.str] mysql_settings: MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        :param pulumi.Input[builtins.str] version: MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if mysql_settings is not None:
            pulumi.set(__self__, "mysql_settings", mysql_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @backup_schedule.setter
    def backup_schedule(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backup_schedule", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        return pulumi.get(self, "mysql_settings")

    @mysql_settings.setter
    def mysql_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mysql_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DbaasMysqlDatabaseTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DbaasMysqlDatabaseTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasMysqlDatabaseTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class DbaasMysqlUserTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DbaasMysqlUserTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasMysqlUserTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class DbaasOpensearchArgsDict(TypedDict):
        dashboards: NotRequired[pulumi.Input['DbaasOpensearchDashboardsArgsDict']]
        """
        OpenSearch Dashboards settings
        """
        fork_from_service: NotRequired[pulumi.Input[builtins.str]]
        """
        ❗ Service name
        """
        index_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbaasOpensearchIndexPatternArgsDict']]]]
        """
        (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        """
        index_template: NotRequired[pulumi.Input['DbaasOpensearchIndexTemplateArgsDict']]
        """
        Template settings for all new indexes
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        """
        keep_index_refresh_interval: NotRequired[pulumi.Input[builtins.bool]]
        """
        Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        max_index_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of indexes to keep (Minimum value is `0`)
        """
        recovery_backup_name: NotRequired[pulumi.Input[builtins.str]]
        """
        ❗ Name of a backup to recover from
        """
        settings: NotRequired[pulumi.Input[builtins.str]]
        """
        OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
elif False:
    DbaasOpensearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasOpensearchArgs:
    def __init__(__self__, *,
                 dashboards: Optional[pulumi.Input['DbaasOpensearchDashboardsArgs']] = None,
                 fork_from_service: Optional[pulumi.Input[builtins.str]] = None,
                 index_patterns: Optional[pulumi.Input[Sequence[pulumi.Input['DbaasOpensearchIndexPatternArgs']]]] = None,
                 index_template: Optional[pulumi.Input['DbaasOpensearchIndexTemplateArgs']] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 keep_index_refresh_interval: Optional[pulumi.Input[builtins.bool]] = None,
                 max_index_count: Optional[pulumi.Input[builtins.int]] = None,
                 recovery_backup_name: Optional[pulumi.Input[builtins.str]] = None,
                 settings: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['DbaasOpensearchDashboardsArgs'] dashboards: OpenSearch Dashboards settings
        :param pulumi.Input[builtins.str] fork_from_service: ❗ Service name
        :param pulumi.Input[Sequence[pulumi.Input['DbaasOpensearchIndexPatternArgs']]] index_patterns: (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        :param pulumi.Input['DbaasOpensearchIndexTemplateArgs'] index_template: Template settings for all new indexes
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        :param pulumi.Input[builtins.bool] keep_index_refresh_interval: Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param pulumi.Input[builtins.int] max_index_count: Maximum number of indexes to keep (Minimum value is `0`)
        :param pulumi.Input[builtins.str] recovery_backup_name: ❗ Name of a backup to recover from
        :param pulumi.Input[builtins.str] settings: OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        :param pulumi.Input[builtins.str] version: ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        if dashboards is not None:
            pulumi.set(__self__, "dashboards", dashboards)
        if fork_from_service is not None:
            pulumi.set(__self__, "fork_from_service", fork_from_service)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            warnings.warn("""This attribute is deprecated and is ignored""", DeprecationWarning)
            pulumi.log.warn("""max_index_count is deprecated: This attribute is deprecated and is ignored""")
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if recovery_backup_name is not None:
            pulumi.set(__self__, "recovery_backup_name", recovery_backup_name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def dashboards(self) -> Optional[pulumi.Input['DbaasOpensearchDashboardsArgs']]:
        """
        OpenSearch Dashboards settings
        """
        return pulumi.get(self, "dashboards")

    @dashboards.setter
    def dashboards(self, value: Optional[pulumi.Input['DbaasOpensearchDashboardsArgs']]):
        pulumi.set(self, "dashboards", value)

    @property
    @pulumi.getter(name="forkFromService")
    def fork_from_service(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ❗ Service name
        """
        return pulumi.get(self, "fork_from_service")

    @fork_from_service.setter
    def fork_from_service(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fork_from_service", value)

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbaasOpensearchIndexPatternArgs']]]]:
        """
        (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        """
        return pulumi.get(self, "index_patterns")

    @index_patterns.setter
    def index_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbaasOpensearchIndexPatternArgs']]]]):
        pulumi.set(self, "index_patterns", value)

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional[pulumi.Input['DbaasOpensearchIndexTemplateArgs']]:
        """
        Template settings for all new indexes
        """
        return pulumi.get(self, "index_template")

    @index_template.setter
    def index_template(self, value: Optional[pulumi.Input['DbaasOpensearchIndexTemplateArgs']]):
        pulumi.set(self, "index_template", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @keep_index_refresh_interval.setter
    def keep_index_refresh_interval(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "keep_index_refresh_interval", value)

    @property
    @pulumi.getter(name="maxIndexCount")
    @_utilities.deprecated("""This attribute is deprecated and is ignored""")
    def max_index_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of indexes to keep (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @max_index_count.setter
    def max_index_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_index_count", value)

    @property
    @pulumi.getter(name="recoveryBackupName")
    def recovery_backup_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ❗ Name of a backup to recover from
        """
        return pulumi.get(self, "recovery_backup_name")

    @recovery_backup_name.setter
    def recovery_backup_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "recovery_backup_name", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DbaasOpensearchDashboardsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable OpenSearch Dashboards (default: true).
        """
        max_old_space_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        """
        request_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
elif False:
    DbaasOpensearchDashboardsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasOpensearchDashboardsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_old_space_size: Optional[pulumi.Input[builtins.int]] = None,
                 request_timeout: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Enable or disable OpenSearch Dashboards (default: true).
        :param pulumi.Input[builtins.int] max_old_space_size: Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        :param pulumi.Input[builtins.int] request_timeout: Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable OpenSearch Dashboards (default: true).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        """
        return pulumi.get(self, "max_old_space_size")

    @max_old_space_size.setter
    def max_old_space_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_old_space_size", value)

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        return pulumi.get(self, "request_timeout")

    @request_timeout.setter
    def request_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "request_timeout", value)


if not MYPY:
    class DbaasOpensearchIndexPatternArgsDict(TypedDict):
        max_index_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        """
        pattern: NotRequired[pulumi.Input[builtins.str]]
        """
        fnmatch pattern
        """
        sorting_algorithm: NotRequired[pulumi.Input[builtins.str]]
        """
        `alphabetical` or `creation_date`.
        """
elif False:
    DbaasOpensearchIndexPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasOpensearchIndexPatternArgs:
    def __init__(__self__, *,
                 max_index_count: Optional[pulumi.Input[builtins.int]] = None,
                 pattern: Optional[pulumi.Input[builtins.str]] = None,
                 sorting_algorithm: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] max_index_count: Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        :param pulumi.Input[builtins.str] pattern: fnmatch pattern
        :param pulumi.Input[builtins.str] sorting_algorithm: `alphabetical` or `creation_date`.
        """
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if sorting_algorithm is not None:
            pulumi.set(__self__, "sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @max_index_count.setter
    def max_index_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_index_count", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        fnmatch pattern
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        `alphabetical` or `creation_date`.
        """
        return pulumi.get(self, "sorting_algorithm")

    @sorting_algorithm.setter
    def sorting_algorithm(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sorting_algorithm", value)


if not MYPY:
    class DbaasOpensearchIndexTemplateArgsDict(TypedDict):
        mapping_nested_objects_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        """
        number_of_replicas: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        """
        number_of_shards: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
elif False:
    DbaasOpensearchIndexTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasOpensearchIndexTemplateArgs:
    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[pulumi.Input[builtins.int]] = None,
                 number_of_replicas: Optional[pulumi.Input[builtins.int]] = None,
                 number_of_shards: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] mapping_nested_objects_limit: The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        :param pulumi.Input[builtins.int] number_of_replicas: The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        :param pulumi.Input[builtins.int] number_of_shards: The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        """
        return pulumi.get(self, "mapping_nested_objects_limit")

    @mapping_nested_objects_limit.setter
    def mapping_nested_objects_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "mapping_nested_objects_limit", value)

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        """
        return pulumi.get(self, "number_of_replicas")

    @number_of_replicas.setter
    def number_of_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "number_of_replicas", value)

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        return pulumi.get(self, "number_of_shards")

    @number_of_shards.setter
    def number_of_shards(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "number_of_shards", value)


if not MYPY:
    class DbaasOpensearchUserTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DbaasOpensearchUserTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasOpensearchUserTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class DbaasPgArgsDict(TypedDict):
        admin_password: NotRequired[pulumi.Input[builtins.str]]
        """
        A custom administrator account password (may only be set at creation time).
        """
        admin_username: NotRequired[pulumi.Input[builtins.str]]
        """
        A custom administrator account username (may only be set at creation time).
        """
        backup_schedule: NotRequired[pulumi.Input[builtins.str]]
        """
        The automated backup schedule (`HH:MM`).
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        pg_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        pgbouncer_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        """
        pglookout_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
elif False:
    DbaasPgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasPgArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[builtins.str]] = None,
                 admin_username: Optional[pulumi.Input[builtins.str]] = None,
                 backup_schedule: Optional[pulumi.Input[builtins.str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 pg_settings: Optional[pulumi.Input[builtins.str]] = None,
                 pgbouncer_settings: Optional[pulumi.Input[builtins.str]] = None,
                 pglookout_settings: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] admin_password: A custom administrator account password (may only be set at creation time).
        :param pulumi.Input[builtins.str] admin_username: A custom administrator account username (may only be set at creation time).
        :param pulumi.Input[builtins.str] backup_schedule: The automated backup schedule (`HH:MM`).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[builtins.str] pg_settings: PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        :param pulumi.Input[builtins.str] pgbouncer_settings: PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        :param pulumi.Input[builtins.str] pglookout_settings: pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        :param pulumi.Input[builtins.str] version: PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if pg_settings is not None:
            pulumi.set(__self__, "pg_settings", pg_settings)
        if pgbouncer_settings is not None:
            pulumi.set(__self__, "pgbouncer_settings", pgbouncer_settings)
        if pglookout_settings is not None:
            pulumi.set(__self__, "pglookout_settings", pglookout_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @backup_schedule.setter
    def backup_schedule(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backup_schedule", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="pgSettings")
    def pg_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        return pulumi.get(self, "pg_settings")

    @pg_settings.setter
    def pg_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pg_settings", value)

    @property
    @pulumi.getter(name="pgbouncerSettings")
    def pgbouncer_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        """
        return pulumi.get(self, "pgbouncer_settings")

    @pgbouncer_settings.setter
    def pgbouncer_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pgbouncer_settings", value)

    @property
    @pulumi.getter(name="pglookoutSettings")
    def pglookout_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        """
        return pulumi.get(self, "pglookout_settings")

    @pglookout_settings.setter
    def pglookout_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pglookout_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DbaasPgDatabaseTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DbaasPgDatabaseTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasPgDatabaseTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class DbaasPgUserTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DbaasPgUserTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasPgUserTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class DbaasRedisArgsDict(TypedDict):
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        redis_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
elif False:
    DbaasRedisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasRedisArgs:
    def __init__(__self__, *,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 redis_settings: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[builtins.str] redis_settings: Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if redis_settings is not None:
            pulumi.set(__self__, "redis_settings", redis_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="redisSettings")
    def redis_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        return pulumi.get(self, "redis_settings")

    @redis_settings.setter
    def redis_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redis_settings", value)


if not MYPY:
    class DbaasTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DbaasTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class DbaasValkeyArgsDict(TypedDict):
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        valkey_settings: NotRequired[pulumi.Input[builtins.str]]
        """
        Valkey configuration settings in JSON format (`exo dbaas type show valkey --settings=valkey` for reference).
        """
elif False:
    DbaasValkeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbaasValkeyArgs:
    def __init__(__self__, *,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 valkey_settings: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param pulumi.Input[builtins.str] valkey_settings: Valkey configuration settings in JSON format (`exo dbaas type show valkey --settings=valkey` for reference).
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if valkey_settings is not None:
            pulumi.set(__self__, "valkey_settings", valkey_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="valkeySettings")
    def valkey_settings(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Valkey configuration settings in JSON format (`exo dbaas type show valkey --settings=valkey` for reference).
        """
        return pulumi.get(self, "valkey_settings")

    @valkey_settings.setter
    def valkey_settings(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "valkey_settings", value)


if not MYPY:
    class ElasticIpHealthcheckArgsDict(TypedDict):
        mode: pulumi.Input[builtins.str]
        """
        The healthcheck mode (`tcp`, `http` or `https`; may only be set at creation time).
        """
        port: pulumi.Input[builtins.int]
        """
        The healthcheck target port (must be between `1` and `65535`).
        """
        interval: NotRequired[pulumi.Input[builtins.int]]
        """
        The healthcheck interval (seconds; must be between `5` and `300`; default: `10`).
        """
        strikes_fail: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of failed healthcheck attempts before considering the target unhealthy (must be between `1` and `20`; default: `2`).
        """
        strikes_ok: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of successful healthcheck attempts before considering the target healthy (must be between `1` and `20`; default: `3`).
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The time before considering a healthcheck probing failed (seconds; must be between `2` and `60`; default: `3`).
        """
        tls_skip_verify: NotRequired[pulumi.Input[builtins.bool]]
        """
        Disable TLS certificate verification for healthcheck in `https` mode (boolean; default: `false`).
        """
        tls_sni: NotRequired[pulumi.Input[builtins.str]]
        """
        The healthcheck server name to present with SNI in `https` mode.
        """
        uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The healthcheck target URI (required in `http(s)` modes).
        """
elif False:
    ElasticIpHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElasticIpHealthcheckArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int],
                 interval: Optional[pulumi.Input[builtins.int]] = None,
                 strikes_fail: Optional[pulumi.Input[builtins.int]] = None,
                 strikes_ok: Optional[pulumi.Input[builtins.int]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 tls_skip_verify: Optional[pulumi.Input[builtins.bool]] = None,
                 tls_sni: Optional[pulumi.Input[builtins.str]] = None,
                 uri: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] mode: The healthcheck mode (`tcp`, `http` or `https`; may only be set at creation time).
        :param pulumi.Input[builtins.int] port: The healthcheck target port (must be between `1` and `65535`).
        :param pulumi.Input[builtins.int] interval: The healthcheck interval (seconds; must be between `5` and `300`; default: `10`).
        :param pulumi.Input[builtins.int] strikes_fail: The number of failed healthcheck attempts before considering the target unhealthy (must be between `1` and `20`; default: `2`).
        :param pulumi.Input[builtins.int] strikes_ok: The number of successful healthcheck attempts before considering the target healthy (must be between `1` and `20`; default: `3`).
        :param pulumi.Input[builtins.int] timeout: The time before considering a healthcheck probing failed (seconds; must be between `2` and `60`; default: `3`).
        :param pulumi.Input[builtins.bool] tls_skip_verify: Disable TLS certificate verification for healthcheck in `https` mode (boolean; default: `false`).
        :param pulumi.Input[builtins.str] tls_sni: The healthcheck server name to present with SNI in `https` mode.
        :param pulumi.Input[builtins.str] uri: The healthcheck target URI (required in `http(s)` modes).
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if strikes_fail is not None:
            pulumi.set(__self__, "strikes_fail", strikes_fail)
        if strikes_ok is not None:
            pulumi.set(__self__, "strikes_ok", strikes_ok)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[builtins.str]:
        """
        The healthcheck mode (`tcp`, `http` or `https`; may only be set at creation time).
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The healthcheck target port (must be between `1` and `65535`).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The healthcheck interval (seconds; must be between `5` and `300`; default: `10`).
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of failed healthcheck attempts before considering the target unhealthy (must be between `1` and `20`; default: `2`).
        """
        return pulumi.get(self, "strikes_fail")

    @strikes_fail.setter
    def strikes_fail(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "strikes_fail", value)

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of successful healthcheck attempts before considering the target healthy (must be between `1` and `20`; default: `3`).
        """
        return pulumi.get(self, "strikes_ok")

    @strikes_ok.setter
    def strikes_ok(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "strikes_ok", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The time before considering a healthcheck probing failed (seconds; must be between `2` and `60`; default: `3`).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Disable TLS certificate verification for healthcheck in `https` mode (boolean; default: `false`).
        """
        return pulumi.get(self, "tls_skip_verify")

    @tls_skip_verify.setter
    def tls_skip_verify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "tls_skip_verify", value)

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The healthcheck server name to present with SNI in `https` mode.
        """
        return pulumi.get(self, "tls_sni")

    @tls_sni.setter
    def tls_sni(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tls_sni", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The healthcheck target URI (required in `http(s)` modes).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class IamApiKeyTimeoutsArgsDict(TypedDict):
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    IamApiKeyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiKeyTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)


if not MYPY:
    class IamOrgPolicyServicesArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['IamOrgPolicyServicesRuleArgsDict']]]]
        """
        List of IAM service rules (if type is `rules`).
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Service type (`rules`, `allow`, or `deny`).
        """
elif False:
    IamOrgPolicyServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamOrgPolicyServicesArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['IamOrgPolicyServicesRuleArgs']]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['IamOrgPolicyServicesRuleArgs']]] rules: List of IAM service rules (if type is `rules`).
        :param pulumi.Input[builtins.str] type: Service type (`rules`, `allow`, or `deny`).
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IamOrgPolicyServicesRuleArgs']]]]:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IamOrgPolicyServicesRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IamOrgPolicyServicesRuleArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[builtins.str]]
        """
        IAM policy rule action (`allow` or `deny`).
        """
        expression: NotRequired[pulumi.Input[builtins.str]]
        """
        IAM policy rule expression.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    IamOrgPolicyServicesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamOrgPolicyServicesRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 expression: Optional[pulumi.Input[builtins.str]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] action: IAM policy rule action (`allow` or `deny`).
        :param pulumi.Input[builtins.str] expression: IAM policy rule expression.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if resources is not None:
            warnings.warn("""This field is not suported. Specify resources using CEL expressions.""", DeprecationWarning)
            pulumi.log.warn("""resources is deprecated: This field is not suported. Specify resources using CEL expressions.""")
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""This field is not suported. Specify resources using CEL expressions.""")
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class IamOrgPolicyTimeoutsArgsDict(TypedDict):
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    IamOrgPolicyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamOrgPolicyTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)


if not MYPY:
    class IamRolePolicyArgsDict(TypedDict):
        default_service_strategy: NotRequired[pulumi.Input[builtins.str]]
        """
        Default service strategy (`allow` or `deny`).
        """
        services: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['IamRolePolicyServicesArgsDict']]]]
        """
        IAM policy services.
        """
elif False:
    IamRolePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamRolePolicyArgs:
    def __init__(__self__, *,
                 default_service_strategy: Optional[pulumi.Input[builtins.str]] = None,
                 services: Optional[pulumi.Input[Mapping[str, pulumi.Input['IamRolePolicyServicesArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] default_service_strategy: Default service strategy (`allow` or `deny`).
        :param pulumi.Input[Mapping[str, pulumi.Input['IamRolePolicyServicesArgs']]] services: IAM policy services.
        """
        if default_service_strategy is not None:
            pulumi.set(__self__, "default_service_strategy", default_service_strategy)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter(name="defaultServiceStrategy")
    def default_service_strategy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default service strategy (`allow` or `deny`).
        """
        return pulumi.get(self, "default_service_strategy")

    @default_service_strategy.setter
    def default_service_strategy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_service_strategy", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['IamRolePolicyServicesArgs']]]]:
        """
        IAM policy services.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['IamRolePolicyServicesArgs']]]]):
        pulumi.set(self, "services", value)


if not MYPY:
    class IamRolePolicyServicesArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['IamRolePolicyServicesRuleArgsDict']]]]
        """
        List of IAM service rules (if type is `rules`).
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Service type (`rules`, `allow`, or `deny`).
        """
elif False:
    IamRolePolicyServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamRolePolicyServicesArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['IamRolePolicyServicesRuleArgs']]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['IamRolePolicyServicesRuleArgs']]] rules: List of IAM service rules (if type is `rules`).
        :param pulumi.Input[builtins.str] type: Service type (`rules`, `allow`, or `deny`).
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IamRolePolicyServicesRuleArgs']]]]:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IamRolePolicyServicesRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IamRolePolicyServicesRuleArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[builtins.str]]
        """
        IAM policy rule action (`allow` or `deny`).
        """
        expression: NotRequired[pulumi.Input[builtins.str]]
        """
        IAM policy rule expression.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    IamRolePolicyServicesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamRolePolicyServicesRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 expression: Optional[pulumi.Input[builtins.str]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] action: IAM policy rule action (`allow` or `deny`).
        :param pulumi.Input[builtins.str] expression: IAM policy rule expression.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if resources is not None:
            warnings.warn("""This field is not suported. Specify resources using CEL expressions.""", DeprecationWarning)
            pulumi.log.warn("""resources is deprecated: This field is not suported. Specify resources using CEL expressions.""")
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""This field is not suported. Specify resources using CEL expressions.""")
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class IamRoleTimeoutsArgsDict(TypedDict):
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    IamRoleTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamRoleTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)


if not MYPY:
    class InstancePoolInstanceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of this resource.
        """
        ipv6_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The instance (main network interface) IPv6 address.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The instance name.
        """
        public_ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The instance (main network interface) IPv4 address.
        """
elif False:
    InstancePoolInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolInstanceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 ipv6_address: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 public_ip_address: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: The ID of this resource.
        :param pulumi.Input[builtins.str] ipv6_address: The instance (main network interface) IPv6 address.
        :param pulumi.Input[builtins.str] name: The instance name.
        :param pulumi.Input[builtins.str] public_ip_address: The instance (main network interface) IPv4 address.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The instance (main network interface) IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The instance name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The instance (main network interface) IPv4 address.
        """
        return pulumi.get(self, "public_ip_address")

    @public_ip_address.setter
    def public_ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_ip_address", value)


if not MYPY:
    class NlbServiceHealthcheckArgsDict(TypedDict):
        port: pulumi.Input[builtins.int]
        """
        The NLB service (TCP/UDP) port.
        """
        interval: NotRequired[pulumi.Input[builtins.int]]
        """
        The healthcheck interval in seconds (default: `10`).
        """
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The healthcheck mode (`tcp`|`http`|`https`; default: `tcp`).
        """
        retries: NotRequired[pulumi.Input[builtins.int]]
        """
        The healthcheck retries (default: `1`).
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The healthcheck timeout (seconds; default: `5`).
        """
        tls_sni: NotRequired[pulumi.Input[builtins.str]]
        """
        The healthcheck TLS SNI server name (only if `mode` is `https`).
        """
        uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The healthcheck URI (must be set only if `mode` is `http(s)`).
        """
elif False:
    NlbServiceHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NlbServiceHealthcheckArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[builtins.int],
                 interval: Optional[pulumi.Input[builtins.int]] = None,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 retries: Optional[pulumi.Input[builtins.int]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 tls_sni: Optional[pulumi.Input[builtins.str]] = None,
                 uri: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] port: The NLB service (TCP/UDP) port.
        :param pulumi.Input[builtins.int] interval: The healthcheck interval in seconds (default: `10`).
        :param pulumi.Input[builtins.str] mode: The healthcheck mode (`tcp`|`http`|`https`; default: `tcp`).
        :param pulumi.Input[builtins.int] retries: The healthcheck retries (default: `1`).
        :param pulumi.Input[builtins.int] timeout: The healthcheck timeout (seconds; default: `5`).
        :param pulumi.Input[builtins.str] tls_sni: The healthcheck TLS SNI server name (only if `mode` is `https`).
        :param pulumi.Input[builtins.str] uri: The healthcheck URI (must be set only if `mode` is `http(s)`).
        """
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The NLB service (TCP/UDP) port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The healthcheck interval in seconds (default: `10`).
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The healthcheck mode (`tcp`|`http`|`https`; default: `tcp`).
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The healthcheck retries (default: `1`).
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The healthcheck timeout (seconds; default: `5`).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The healthcheck TLS SNI server name (only if `mode` is `https`).
        """
        return pulumi.get(self, "tls_sni")

    @tls_sni.setter
    def tls_sni(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tls_sni", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The healthcheck URI (must be set only if `mode` is `http(s)`).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class SksClusterOidcArgsDict(TypedDict):
        client_id: pulumi.Input[builtins.str]
        """
        The OpenID client ID.
        """
        issuer_url: pulumi.Input[builtins.str]
        """
        The OpenID provider URL.
        """
        groups_claim: NotRequired[pulumi.Input[builtins.str]]
        """
        An OpenID JWT claim to use as the user's group.
        """
        groups_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        An OpenID prefix prepended to group claims.
        """
        required_claim: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        username_claim: NotRequired[pulumi.Input[builtins.str]]
        """
        An OpenID JWT claim to use as the user name.
        """
        username_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        An OpenID prefix prepended to username claims.
        """
elif False:
    SksClusterOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SksClusterOidcArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[builtins.str],
                 issuer_url: pulumi.Input[builtins.str],
                 groups_claim: Optional[pulumi.Input[builtins.str]] = None,
                 groups_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 required_claim: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 username_claim: Optional[pulumi.Input[builtins.str]] = None,
                 username_prefix: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] client_id: The OpenID client ID.
        :param pulumi.Input[builtins.str] issuer_url: The OpenID provider URL.
        :param pulumi.Input[builtins.str] groups_claim: An OpenID JWT claim to use as the user's group.
        :param pulumi.Input[builtins.str] groups_prefix: An OpenID prefix prepended to group claims.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param pulumi.Input[builtins.str] username_claim: An OpenID JWT claim to use as the user name.
        :param pulumi.Input[builtins.str] username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[builtins.str]:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> pulumi.Input[builtins.str]:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "issuer_url", value)

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @groups_claim.setter
    def groups_claim(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "groups_claim", value)

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @groups_prefix.setter
    def groups_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "groups_prefix", value)

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @required_claim.setter
    def required_claim(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "required_claim", value)

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @username_claim.setter
    def username_claim(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_claim", value)

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")

    @username_prefix.setter
    def username_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_prefix", value)


if not MYPY:
    class SksNodepoolKubeletImageGcArgsDict(TypedDict):
        high_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        The percent of disk usage after which image garbage collection is always run
        """
        low_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        The percent of disk usage before which image garbage collection is never run
        """
        min_age: NotRequired[pulumi.Input[builtins.str]]
        """
        The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
elif False:
    SksNodepoolKubeletImageGcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SksNodepoolKubeletImageGcArgs:
    def __init__(__self__, *,
                 high_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 low_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 min_age: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] high_threshold: The percent of disk usage after which image garbage collection is always run
        :param pulumi.Input[builtins.int] low_threshold: The percent of disk usage before which image garbage collection is never run
        :param pulumi.Input[builtins.str] min_age: The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        if high_threshold is not None:
            pulumi.set(__self__, "high_threshold", high_threshold)
        if low_threshold is not None:
            pulumi.set(__self__, "low_threshold", low_threshold)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)

    @property
    @pulumi.getter(name="highThreshold")
    def high_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The percent of disk usage after which image garbage collection is always run
        """
        return pulumi.get(self, "high_threshold")

    @high_threshold.setter
    def high_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "high_threshold", value)

    @property
    @pulumi.getter(name="lowThreshold")
    def low_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The percent of disk usage before which image garbage collection is never run
        """
        return pulumi.get(self, "low_threshold")

    @low_threshold.setter
    def low_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "low_threshold", value)

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        return pulumi.get(self, "min_age")

    @min_age.setter
    def min_age(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "min_age", value)


if not MYPY:
    class SosBucketPolicyTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    SosBucketPolicyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SosBucketPolicyTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class GetBlockStorageVolumeSnapshotTimeoutsArgsDict(TypedDict):
        read: NotRequired[builtins.str]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    GetBlockStorageVolumeSnapshotTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBlockStorageVolumeSnapshotTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[builtins.str]):
        pulumi.set(self, "read", value)


if not MYPY:
    class GetBlockStorageVolumeTimeoutsArgsDict(TypedDict):
        read: NotRequired[builtins.str]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    GetBlockStorageVolumeTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBlockStorageVolumeTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[builtins.str]):
        pulumi.set(self, "read", value)


if not MYPY:
    class GetDatabaseUriTimeoutsArgsDict(TypedDict):
        read: NotRequired[builtins.str]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    GetDatabaseUriTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDatabaseUriTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[builtins.str]):
        pulumi.set(self, "read", value)


if not MYPY:
    class GetDomainRecordFilterArgsDict(TypedDict):
        content_regex: NotRequired[builtins.str]
        """
        A regular expression to match the record content.
        """
        id: NotRequired[builtins.str]
        """
        The record ID to match.
        """
        name: NotRequired[builtins.str]
        """
        The domain record name to match.
        """
        record_type: NotRequired[builtins.str]
        """
        The record type to match.
        """
elif False:
    GetDomainRecordFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDomainRecordFilterArgs:
    def __init__(__self__, *,
                 content_regex: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 record_type: Optional[builtins.str] = None):
        """
        :param builtins.str content_regex: A regular expression to match the record content.
        :param builtins.str id: The record ID to match.
        :param builtins.str name: The domain record name to match.
        :param builtins.str record_type: The record type to match.
        """
        if content_regex is not None:
            pulumi.set(__self__, "content_regex", content_regex)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)

    @property
    @pulumi.getter(name="contentRegex")
    def content_regex(self) -> Optional[builtins.str]:
        """
        A regular expression to match the record content.
        """
        return pulumi.get(self, "content_regex")

    @content_regex.setter
    def content_regex(self, value: Optional[builtins.str]):
        pulumi.set(self, "content_regex", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The record ID to match.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The domain record name to match.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[builtins.str]:
        """
        The record type to match.
        """
        return pulumi.get(self, "record_type")

    @record_type.setter
    def record_type(self, value: Optional[builtins.str]):
        pulumi.set(self, "record_type", value)


if not MYPY:
    class GetIamApiKeyTimeoutsArgsDict(TypedDict):
        read: NotRequired[builtins.str]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    GetIamApiKeyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIamApiKeyTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[builtins.str]):
        pulumi.set(self, "read", value)


if not MYPY:
    class GetIamOrgPolicyTimeoutsArgsDict(TypedDict):
        read: NotRequired[builtins.str]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    GetIamOrgPolicyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIamOrgPolicyTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[builtins.str]):
        pulumi.set(self, "read", value)


if not MYPY:
    class GetIamRoleTimeoutsArgsDict(TypedDict):
        read: NotRequired[builtins.str]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    GetIamRoleTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIamRoleTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[builtins.str]):
        pulumi.set(self, "read", value)


if not MYPY:
    class GetNlbServiceListTimeoutsArgsDict(TypedDict):
        read: NotRequired[builtins.str]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    GetNlbServiceListTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNlbServiceListTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[builtins.str]):
        pulumi.set(self, "read", value)


if not MYPY:
    class GetSksClusterOidcArgsDict(TypedDict):
        client_id: builtins.str
        """
        The OpenID client ID.
        """
        issuer_url: builtins.str
        """
        The OpenID provider URL.
        """
        groups_claim: NotRequired[builtins.str]
        """
        An OpenID JWT claim to use as the user's group.
        """
        groups_prefix: NotRequired[builtins.str]
        """
        An OpenID prefix prepended to group claims.
        """
        required_claim: NotRequired[Mapping[str, builtins.str]]
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        username_claim: NotRequired[builtins.str]
        """
        An OpenID JWT claim to use as the user name.
        """
        username_prefix: NotRequired[builtins.str]
        """
        An OpenID prefix prepended to username claims.
        """
elif False:
    GetSksClusterOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSksClusterOidcArgs:
    def __init__(__self__, *,
                 client_id: builtins.str,
                 issuer_url: builtins.str,
                 groups_claim: Optional[builtins.str] = None,
                 groups_prefix: Optional[builtins.str] = None,
                 required_claim: Optional[Mapping[str, builtins.str]] = None,
                 username_claim: Optional[builtins.str] = None,
                 username_prefix: Optional[builtins.str] = None):
        """
        :param builtins.str client_id: The OpenID client ID.
        :param builtins.str issuer_url: The OpenID provider URL.
        :param builtins.str groups_claim: An OpenID JWT claim to use as the user's group.
        :param builtins.str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, builtins.str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param builtins.str username_claim: An OpenID JWT claim to use as the user name.
        :param builtins.str username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: builtins.str):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> builtins.str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: builtins.str):
        pulumi.set(self, "issuer_url", value)

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[builtins.str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @groups_claim.setter
    def groups_claim(self, value: Optional[builtins.str]):
        pulumi.set(self, "groups_claim", value)

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[builtins.str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @groups_prefix.setter
    def groups_prefix(self, value: Optional[builtins.str]):
        pulumi.set(self, "groups_prefix", value)

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @required_claim.setter
    def required_claim(self, value: Optional[Mapping[str, builtins.str]]):
        pulumi.set(self, "required_claim", value)

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[builtins.str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @username_claim.setter
    def username_claim(self, value: Optional[builtins.str]):
        pulumi.set(self, "username_claim", value)

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[builtins.str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")

    @username_prefix.setter
    def username_prefix(self, value: Optional[builtins.str]):
        pulumi.set(self, "username_prefix", value)


if not MYPY:
    class GetSksNodepoolKubeletImageGcArgsDict(TypedDict):
        high_threshold: NotRequired[builtins.int]
        """
        The percent of disk usage after which image garbage collection is always run
        """
        low_threshold: NotRequired[builtins.int]
        """
        The percent of disk usage before which image garbage collection is never run
        """
        min_age: NotRequired[builtins.str]
        """
        The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
elif False:
    GetSksNodepoolKubeletImageGcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSksNodepoolKubeletImageGcArgs:
    def __init__(__self__, *,
                 high_threshold: Optional[builtins.int] = None,
                 low_threshold: Optional[builtins.int] = None,
                 min_age: Optional[builtins.str] = None):
        """
        :param builtins.int high_threshold: The percent of disk usage after which image garbage collection is always run
        :param builtins.int low_threshold: The percent of disk usage before which image garbage collection is never run
        :param builtins.str min_age: The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        if high_threshold is not None:
            pulumi.set(__self__, "high_threshold", high_threshold)
        if low_threshold is not None:
            pulumi.set(__self__, "low_threshold", low_threshold)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)

    @property
    @pulumi.getter(name="highThreshold")
    def high_threshold(self) -> Optional[builtins.int]:
        """
        The percent of disk usage after which image garbage collection is always run
        """
        return pulumi.get(self, "high_threshold")

    @high_threshold.setter
    def high_threshold(self, value: Optional[builtins.int]):
        pulumi.set(self, "high_threshold", value)

    @property
    @pulumi.getter(name="lowThreshold")
    def low_threshold(self) -> Optional[builtins.int]:
        """
        The percent of disk usage before which image garbage collection is never run
        """
        return pulumi.get(self, "low_threshold")

    @low_threshold.setter
    def low_threshold(self, value: Optional[builtins.int]):
        pulumi.set(self, "low_threshold", value)

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[builtins.str]:
        """
        The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        return pulumi.get(self, "min_age")

    @min_age.setter
    def min_age(self, value: Optional[builtins.str]):
        pulumi.set(self, "min_age", value)


if not MYPY:
    class GetSosBucketPolicyTimeoutsArgsDict(TypedDict):
        read: NotRequired[builtins.str]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    GetSosBucketPolicyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSosBucketPolicyTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[builtins.str] = None):
        """
        :param builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[builtins.str]):
        pulumi.set(self, "read", value)


